diff --git a/apps/build.info b/apps/build.info
index 020d129..3d52fb2 100644
--- a/apps/build.info
+++ b/apps/build.info
@@ -54,6 +54,10 @@ ENDIF
 IF[{- !$disabled{'cmp'} -}]
   $OPENSSLSRC=$OPENSSLSRC cmp.c lib/cmp_mock_srv.c
 ENDIF
+# Добавляем поддержку для 'hdlp'
+IF[{- !$disabled{'hdlp'} -}]
+  $OPENSSLSRC=$OPENSSLSRC hdlpparam.c hdlp.c genhdlp.c derivehdlp.c
+ENDIF
 
 IF[{- !$disabled{apps} -}]
   PROGRAMS=openssl
diff --git a/apps/derivehdlp.c b/apps/derivehdlp.c
new file mode 100644
index 0000000..4dc8461
--- /dev/null
+++ b/apps/derivehdlp.c
@@ -0,0 +1,157 @@
+#include "apps.h"
+#include "progs.h"
+#include <string.h>
+#include <openssl/err.h>
+#include <openssl/pem.h>
+#include <openssl/evp.h>
+#include <sys/stat.h>
+
+#include <include/openssl/hdlp.h>  // В этом файле определены структуры и функции HDLP
+
+static int verbose = 1;
+
+typedef enum OPTION_choice {
+    OPT_COMMON,
+    OPT_OUT,
+    OPT_TEXT, OPT_VERBOSE, OPT_QUIET,
+    OPT_INKEY, OPT_PEERKEY,
+    OPT_PEERFORM, OPT_KEYFORM
+} OPTION_CHOICE;
+
+const OPTIONS derivehdlp_options[] = {
+    OPT_SECTION("General"),
+    {"help", OPT_HELP, '-', "Display this summary"},
+
+    OPT_SECTION("Input"),
+    {"inkey", OPT_INKEY, '<', "Private key input file"},
+    {"peerkey", OPT_PEERKEY, '<', "Partner's private key"},
+    {"peerform", OPT_PEERFORM, 'F', "Peer key format (DER/PEM)"},
+    {"keyform", OPT_KEYFORM, 'F', "Private key format (DER/PEM)"},
+
+    OPT_SECTION("Output"),
+    {"out", OPT_OUT, '>', "Output file - file containing the secret"},
+    {"text", OPT_TEXT, '-', "Print secret in text"},
+    {"verbose", OPT_VERBOSE, '-', "Output status while generating secret"},
+    {"quiet", OPT_QUIET, '-', "Do not output status while generating secret"},
+
+    {NULL}
+};
+
+int derivehdlp_main(int argc, char **argv)
+{
+    BIO *in = NULL, *out = NULL;
+    char *outfile = NULL;
+    char *prog;
+    OPTION_CHOICE o;
+    int keyform = FORMAT_PEM, peerform = FORMAT_PEM;
+    int ret = 1, text = 0;
+    const char *inkey = NULL;
+    const char *peerkey = NULL;
+
+    prog = opt_init(argc, argv, derivehdlp_options);
+
+    while ((o = opt_next()) != OPT_EOF) {
+        switch (o) {
+        case OPT_EOF:
+        case OPT_ERR:
+ opthelp:
+            BIO_printf(bio_err, "%s: Use -help for summary.\n", prog);
+            goto end;
+        case OPT_HELP:
+            opt_help(derivehdlp_options);
+            ret = 0;
+            goto end;
+        case OPT_OUT:
+            outfile = opt_arg();
+            break;
+        case OPT_INKEY:
+            inkey = opt_arg();
+            break;
+        case OPT_PEERKEY:
+            peerkey = opt_arg();
+            break;
+        case OPT_PEERFORM:
+            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &peerform))
+                goto opthelp;
+            break;
+        case OPT_KEYFORM:
+            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &keyform))
+                goto opthelp;
+            break;
+        case OPT_TEXT:
+            text = 1;
+            break;
+        }
+    }
+
+    /* No extra arguments. */
+    if (!opt_check_rest_arg(NULL))
+        goto opthelp;
+
+    if (!app_RAND_load())
+        goto end;
+
+    if (inkey == NULL || peerkey == NULL || outfile == NULL){
+        goto opthelp;
+    }
+
+
+    HDLP_PUBLIC_KEY *pub_key =HDLP_PUBLIC_KEY_new();
+    HDLP_PRIVATE_KEY *priv_key = HDLP_PRIVATE_KEY_new();
+    BN_CTX *bn_ctx = BN_CTX_new();
+    if (!pub_key || !priv_key || !bn_ctx){
+        BIO_printf(bio_err, "Error, HDLP keys generation context allocation failed\n");
+        goto end;
+    }
+
+    // Считать чужой открытый ключ
+    pub_key = read_HDLP_public_key(peerkey, peerform);
+    if (pub_key == NULL){
+        BIO_printf(bio_err, "Error, the public key could not be read\n");
+        goto end;
+    }
+
+    // Считать свой закрытый ключ
+    priv_key = read_HDLP_private_key(inkey, keyform);
+    if (priv_key == NULL){
+        BIO_printf(bio_err, "Error, the private key could not be read\n");
+        goto end;
+    }
+
+    // Открытие файла для записи
+    out = bio_open_default(outfile, 'w', FORMAT_BINARY);
+    if (out == NULL)
+        goto end;
+
+    // Генерация секрета
+
+    if (verbose)
+        BIO_printf(bio_err, "Generating HDLP secret\n");
+
+    HDLP_SECRET *secret = HDLP_SECRET_new();
+    secret = genSecret(pub_key, priv_key, bn_ctx);
+
+    //Сохранение в файл
+    unsigned char *data = NULL;
+    int len = encode_hdlp_secret(secret, &data);
+
+    BIO_write(out, data, len);
+
+    // Вывод на экран
+    if (text){
+        print_HDLP_SECRET(secret);
+    }
+
+    if (verbose)
+        BIO_printf(bio_err, "The secret was successfully saved in file %s\n", outfile);
+
+    ret = 0;
+
+ end:
+    if (ret != 0)
+        ERR_print_errors(bio_err);
+    BIO_free(in);
+    BIO_free_all(out);
+    return ret;
+}
+
diff --git a/apps/genhdlp.c b/apps/genhdlp.c
new file mode 100644
index 0000000..b02b3ce
--- /dev/null
+++ b/apps/genhdlp.c
@@ -0,0 +1,179 @@
+#include <stdio.h>
+#include <string.h>
+#include "apps.h"
+#include "progs.h"
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+
+#include <include/openssl/hdlp.h>  // В этом файле определены структуры и функции HDLP
+
+static int verbose = 1;
+
+typedef enum OPTION_choice {
+    OPT_COMMON,
+    OPT_OUTFORM, OPT_OUT, OPT_PARAMFILE, OPT_INFORM,
+    OPT_TEXT,
+    OPT_VERBOSE, OPT_QUIET, OPT_OUTPUBKEY
+} OPTION_CHOICE;
+
+const OPTIONS genhdlp_options[] = {
+    OPT_SECTION("General"),
+    {"help", OPT_HELP, '-', "Display this summary"},
+
+    OPT_SECTION("Input"),
+    {"paramfile", OPT_PARAMFILE, '<', "Parameters file"},
+    {"inform", OPT_INFORM, 'F', "Parameters file format, DER or PEM"},
+    
+    OPT_SECTION("Output"),
+    {"out", OPT_OUT, '>', "Output (private key) file"},
+    {"outpubkey", OPT_OUTPUBKEY, '>', "Output public key file"},
+    {"outform", OPT_OUTFORM, 'F', "output format (DER or PEM)"},
+    
+    {"text", OPT_TEXT, '-', "Print all in text"},
+    {"verbose", OPT_VERBOSE, '-', "Output status while generating keys"},
+    {"quiet", OPT_QUIET, '-', "Do not output status while generating keys"},
+
+    {NULL}
+};
+
+int genhdlp_main(int argc, char **argv)
+{
+    BIO *in = NULL, *out = NULL, *outpubkey = NULL;
+    char *outfile = NULL, *passarg = NULL, *pass = NULL, *prog, *p;
+    char *outpubkeyfile = NULL;
+    const char *ciphername = NULL, *paramfile = NULL;
+    EVP_CIPHER *cipher = NULL;
+    OPTION_CHOICE o;
+    int informat = FORMAT_PEM, outformat = FORMAT_PEM, text = 0, ret = 1, rv;
+    int i;
+
+    prog = opt_init(argc, argv, genhdlp_options);
+
+    while ((o = opt_next()) != OPT_EOF) {
+        switch (o) {
+        case OPT_EOF:
+        case OPT_ERR:
+ opthelp:
+            BIO_printf(bio_err, "%s: Use -help for summary.\n", prog);
+            goto end;
+        case OPT_HELP:
+            ret = 0;
+            opt_help(genhdlp_options);
+            goto end;
+        case OPT_OUTFORM:
+            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))
+                goto opthelp;
+            break;
+        case OPT_INFORM:
+            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))
+                goto opthelp;
+            break;
+        case OPT_OUT:
+            outfile = opt_arg();
+            break;
+        case OPT_OUTPUBKEY:
+            outpubkeyfile = opt_arg();
+            break;
+        case OPT_PARAMFILE:
+            paramfile = opt_arg();
+            break;
+        case OPT_QUIET:
+            verbose = 0;
+            break;
+        case OPT_VERBOSE:
+            verbose = 1;
+            break;
+        case OPT_TEXT:
+            text = 1;
+            break;
+        }
+    }
+
+    //Проверка на лишние аргументы
+    if (!opt_check_rest_arg(NULL))
+        goto opthelp;
+
+    if (!app_RAND_load())
+        goto end;
+
+    //Считывание параметров
+    HDLP_PARAMS *params = HDLP_PARAMS_new();
+    params = read_HDLP_params(paramfile, informat);
+        if (params == NULL){
+            BIO_printf(bio_err, "Error, the parameters could not be read\n");
+            goto end;
+        }
+
+    out = bio_open_owner(outfile, outformat, 1);
+    if (out == NULL)
+        goto end;
+
+    outpubkey = bio_open_owner(outpubkeyfile, outformat, 1);
+    if (outpubkey == NULL)
+        goto end;
+
+    if (verbose)
+            BIO_printf(bio_err, "Generating HDLP keys\n");
+
+    //Генерация ключей
+    HDLP_PUBLIC_KEY *pub_key = HDLP_PUBLIC_KEY_new();
+    HDLP_PRIVATE_KEY *priv_key = HDLP_PRIVATE_KEY_new();
+    BN_CTX *bn_ctx = BN_CTX_new();
+    if (!pub_key || !priv_key || !bn_ctx){
+        BIO_printf(bio_err, "Error, HDLP keys generation context allocation failed\n");
+        goto end;
+    }
+    gen_HDLP_keys(pub_key, priv_key, params, bn_ctx);
+
+    //Сохранение в файл
+    unsigned char *dataPrivKey = NULL, *dataPubKey = NULL;
+    int lenPrivKey = encode_hdlp_priv_key(priv_key, &dataPrivKey);
+    int lenPubKey = encode_hdlp_pub_key(pub_key, &dataPubKey);
+ 
+    if (outformat == FORMAT_PEM) { //PEM
+
+        int ret = PEM_write_bio(out, "HDLP PRIVATE KEY", NULL, dataPrivKey, lenPrivKey);
+        int ret1 = PEM_write_bio(outpubkey, "HDLP PUBLIC KEY", NULL, dataPubKey, lenPubKey);
+
+    } else if (outformat == FORMAT_ASN1) { //DER
+
+        BIO_write(out, dataPrivKey, lenPrivKey);
+        BIO_write(outpubkey, dataPubKey, lenPubKey);
+
+    } else {
+        BIO_printf(bio_err, "Bad format specified for key\n");
+        goto end;
+    }
+
+    ret = 0;
+
+    // Вывод на экран
+    if (text) {
+        
+        print_HDLP_params(params, 0);
+        print_HDLP_PUBLIC_KEY(pub_key);
+        print_HDLP_PRIVATE_KEY(priv_key);
+ 
+    }
+
+    if (verbose){
+            BIO_printf(bio_err, "The public key was successfully saved in file %s\n", outpubkeyfile);
+            BIO_printf(bio_err, "The private key was successfully saved in file %s\n", outfile);
+        }
+
+
+
+
+
+
+ end:
+    if (ret != 0)
+        ERR_print_errors(bio_err);
+    EVP_CIPHER_free(cipher);
+    BIO_free_all(out);
+    BIO_free_all(outpubkey);
+    BIO_free(in);
+    OPENSSL_free(pass);
+    return ret;
+}
diff --git a/apps/hdlp.c b/apps/hdlp.c
new file mode 100644
index 0000000..6deff62
--- /dev/null
+++ b/apps/hdlp.c
@@ -0,0 +1,1511 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <locale.h>
+#include <stdbool.h>
+#include <openssl/bn.h>
+#include <openssl/rand.h>
+#include <openssl/opensslconf.h>
+
+#include <include/openssl/hdlp.h>  // В этом файле определены структуры и функции HDLP
+
+#include <openssl/pem.h>
+#include <openssl/asn1.h>
+
+#include <time.h>
+#include "apps.h"
+#include "progs.h"
+
+
+#define VECTOR_SIZE 4
+
+// Функция для создания HDLP_PARAMS
+HDLP_PARAMS *HDLP_PARAMS_new() {
+    HDLP_PARAMS *params = OPENSSL_zalloc(sizeof(HDLP_PARAMS));
+    if (!params)
+        return NULL;
+
+    params->p = BN_new();
+    params->u = BN_new();
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        params->Q[i] = BN_new();
+        params->N[i] = BN_new();
+    }
+    return params;
+}
+
+// Функция для освобождения HDLP_PARAMS
+void HDLP_PARAMS_free(HDLP_PARAMS *params) {
+    if (!params)
+        return;
+
+    BN_free(params->p);
+    BN_free(params->u);
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_free(params->Q[i]);
+        BN_free(params->N[i]);
+    }
+    OPENSSL_free(params);
+}
+
+// Функция для создания HDLP_PUBLIC_KEY
+HDLP_PUBLIC_KEY *HDLP_PUBLIC_KEY_new() {
+    HDLP_PUBLIC_KEY *pub_key = OPENSSL_zalloc(sizeof(HDLP_PUBLIC_KEY));
+    if (!pub_key)
+        return NULL;
+
+    pub_key->p = BN_new();
+    pub_key->u = BN_new();
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        pub_key->Q[i] = BN_new();
+        pub_key->N[i] = BN_new();
+        pub_key->Y[i] = BN_new();
+    }
+    return pub_key;
+}
+
+// Функция для освобождения HDLP_PUBLIC_KEY
+void HDLP_PUBLIC_KEY_free(HDLP_PUBLIC_KEY *pub_key) {
+    if (!pub_key)
+        return;
+
+    BN_free(pub_key->p);
+    BN_free(pub_key->u);
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_free(pub_key->Q[i]);
+        BN_free(pub_key->N[i]);
+        BN_free(pub_key->Y[i]);
+    }
+    OPENSSL_free(pub_key);
+}
+
+// Функция для создания HDLP_PRIVATE_KEY
+HDLP_PRIVATE_KEY *HDLP_PRIVATE_KEY_new() {
+    HDLP_PRIVATE_KEY *priv_key = OPENSSL_zalloc(sizeof(HDLP_PRIVATE_KEY));
+    if (!priv_key)
+        return NULL;
+
+    priv_key->t = BN_new();
+    priv_key->x = BN_new();
+
+    return priv_key;
+}
+
+// Функция для освобождения HDLP_PRIVATE_KEY
+void HDLP_PRIVATE_KEY_free(HDLP_PRIVATE_KEY *priv_key) {
+    if (!priv_key)
+        return;
+
+    BN_free(priv_key->t);
+    BN_free(priv_key->x);
+
+    OPENSSL_free(priv_key);
+}
+
+// Функция для создания HDLP_SECRET
+HDLP_SECRET *HDLP_SECRET_new() {
+    HDLP_SECRET *secret = OPENSSL_zalloc(sizeof(HDLP_SECRET));
+    if (!secret)
+        return NULL;
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        secret->Z[i] = BN_new();
+    }
+    return secret;
+}
+
+// Функция для освобождения HDLP_SECRET
+void HDLP_SECRET_free(HDLP_SECRET *secret) {
+    if (!secret)
+        return;
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_free(secret->Z[i]);
+    }
+    OPENSSL_free(secret);
+}
+
+// Функция для создания HDLP_PARAMS_ASN1
+HDLP_PARAMS_ASN1 *HDLP_PARAMS_ASN1_new() {
+    // Выделяем память для структуры
+    HDLP_PARAMS_ASN1 *params_asn1 = OPENSSL_malloc(sizeof(HDLP_PARAMS_ASN1));
+    if (params_asn1 == NULL) {
+        return NULL;
+    }
+
+    // Инициализируем поля структуры
+    params_asn1->p = ASN1_INTEGER_new();
+    params_asn1->u = ASN1_INTEGER_new();
+    params_asn1->Q = sk_ASN1_INTEGER_new_null();
+    params_asn1->N = sk_ASN1_INTEGER_new_null();
+
+    // Инициализация элементов в Q и N
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *q_val = ASN1_INTEGER_new();
+        ASN1_INTEGER *n_val = ASN1_INTEGER_new();
+        if (!q_val || !n_val || 
+            !sk_ASN1_INTEGER_push(params_asn1->Q, q_val) || 
+            !sk_ASN1_INTEGER_push(params_asn1->N, n_val)) {
+            ASN1_INTEGER_free(q_val);
+            ASN1_INTEGER_free(n_val);
+            HDLP_PARAMS_ASN1_free(params_asn1);
+            return NULL;
+        }
+    }
+
+    return params_asn1;
+}
+
+// Функция для освобождения HDLP_PARAMS_ASN1
+void HDLP_PARAMS_ASN1_free(HDLP_PARAMS_ASN1 *params_asn1) {
+    if (params_asn1 == NULL) return;
+
+    ASN1_INTEGER_free(params_asn1->p);
+    ASN1_INTEGER_free(params_asn1->u);
+
+    // Освобождаем элементы стека Q и N
+    sk_ASN1_INTEGER_pop_free(params_asn1->Q, ASN1_INTEGER_free);
+    sk_ASN1_INTEGER_pop_free(params_asn1->N, ASN1_INTEGER_free);
+
+    // Освобождаем саму структуру
+    OPENSSL_free(params_asn1);
+}
+
+// Функция для создания HDLP_PUBLIC_KEY_ASN1
+HDLP_PUBLIC_KEY_ASN1 *HDLP_PUBLIC_KEY_ASN1_new() {
+    // Выделяем память для структуры
+    HDLP_PUBLIC_KEY_ASN1 *pub_key_asn1 = OPENSSL_malloc(sizeof(HDLP_PUBLIC_KEY_ASN1));
+    if (pub_key_asn1 == NULL) {
+        return NULL;
+    }
+
+    // Инициализируем поля структуры
+    pub_key_asn1->p = ASN1_INTEGER_new();
+    pub_key_asn1->u = ASN1_INTEGER_new();
+    pub_key_asn1->Q = sk_ASN1_INTEGER_new_null();
+    pub_key_asn1->N = sk_ASN1_INTEGER_new_null();
+    pub_key_asn1->Y = sk_ASN1_INTEGER_new_null();
+
+    // Инициализация элементов в Q,N,Y
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *q_val = ASN1_INTEGER_new();
+        ASN1_INTEGER *n_val = ASN1_INTEGER_new();
+        ASN1_INTEGER *y_val = ASN1_INTEGER_new();
+        if (!q_val || !n_val || 
+            !sk_ASN1_INTEGER_push(pub_key_asn1->Q, q_val) || 
+            !sk_ASN1_INTEGER_push(pub_key_asn1->N, n_val) ||
+            !sk_ASN1_INTEGER_push(pub_key_asn1->Y, y_val)) {
+            ASN1_INTEGER_free(q_val);
+            ASN1_INTEGER_free(n_val);
+            ASN1_INTEGER_free(y_val);
+            HDLP_PUBLIC_KEY_ASN1_free(pub_key_asn1);
+            return NULL;
+        }
+    }
+
+    return pub_key_asn1;
+}
+
+// Функция для освобождения HDLP_PUBLIC_KEY_ASN1
+void HDLP_PUBLIC_KEY_ASN1_free(HDLP_PUBLIC_KEY_ASN1 *pub_key_asn1) {
+    if (pub_key_asn1 == NULL) return;
+
+    ASN1_INTEGER_free(pub_key_asn1->p);
+    ASN1_INTEGER_free(pub_key_asn1->u);
+
+    // Освобождаем элементы стека Q, N и Y
+    sk_ASN1_INTEGER_pop_free(pub_key_asn1->Q, ASN1_INTEGER_free);
+    sk_ASN1_INTEGER_pop_free(pub_key_asn1->N, ASN1_INTEGER_free);
+    sk_ASN1_INTEGER_pop_free(pub_key_asn1->Y, ASN1_INTEGER_free);
+
+    // Освобождаем саму структуру
+    OPENSSL_free(pub_key_asn1);
+}
+
+// Функция для создания HDLP_PRIVATE_KEY_ASN1
+HDLP_PRIVATE_KEY_ASN1 *HDLP_PRIVATE_KEY_ASN1_new() {
+    // Выделяем память для структуры
+    HDLP_PRIVATE_KEY_ASN1 *priv_key_asn1 = OPENSSL_malloc(sizeof(HDLP_PRIVATE_KEY_ASN1));
+    if (priv_key_asn1 == NULL) {
+        return NULL;
+    }
+
+    // Инициализируем поля структуры
+    priv_key_asn1->x = ASN1_INTEGER_new();
+    priv_key_asn1->t = ASN1_INTEGER_new();
+
+    return priv_key_asn1;
+}
+
+// Функция для освобождения HDLP_PRIVATE_KEY_ASN1
+void HDLP_PRIVATE_KEY_ASN1_free(HDLP_PRIVATE_KEY_ASN1 *priv_key_asn1) {
+    if (priv_key_asn1 == NULL) return;
+
+    ASN1_INTEGER_free(priv_key_asn1->x);
+    ASN1_INTEGER_free(priv_key_asn1->t);
+
+    // Освобождаем саму структуру
+    OPENSSL_free(priv_key_asn1);
+}
+
+// Функция для создания HDLP_SECRET_ASN1
+HDLP_SECRET_ASN1 *HDLP_SECRET_ASN1_new() {
+    // Выделяем память для структуры
+    HDLP_SECRET_ASN1 *secret_asn1 = OPENSSL_malloc(sizeof(HDLP_SECRET_ASN1));
+    if (secret_asn1 == NULL) {
+        return NULL;
+    }
+
+    // Инициализируем поля структуры
+    secret_asn1->Z = sk_ASN1_INTEGER_new_null();
+
+    // Инициализация элементов в Z
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *z_val = ASN1_INTEGER_new();
+        if (!z_val || 
+            !sk_ASN1_INTEGER_push(secret_asn1->Z, z_val)) {
+            ASN1_INTEGER_free(z_val);
+            HDLP_SECRET_ASN1_free(secret_asn1);
+            return NULL;
+        }
+    }
+
+    return secret_asn1;
+}
+
+// Функция для освобождения HDLP_SECRET_ASN1
+void HDLP_SECRET_ASN1_free(HDLP_SECRET_ASN1 *secret_asn1) {
+    if (secret_asn1 == NULL) return;
+
+    // Освобождаем элементы стека Z
+    sk_ASN1_INTEGER_pop_free(secret_asn1->Z, ASN1_INTEGER_free);
+
+    // Освобождаем саму структуру
+    OPENSSL_free(secret_asn1);
+}
+
+// Функция преобразования HDLP_PARAMS в ASN1 структуру
+HDLP_PARAMS_ASN1 *hdlp_params2hdlp_params_asn1(HDLP_PARAMS *params) {
+    HDLP_PARAMS_ASN1 *params_asn1 = OPENSSL_zalloc(sizeof(HDLP_PARAMS_ASN1));
+    if (!params_asn1) return NULL;
+
+    // Инициализация ASN1_INTEGER и преобразование BIGNUM в ASN1_INTEGER
+    params_asn1->p = BN_to_ASN1_INTEGER(params->p, NULL);
+    params_asn1->u = BN_to_ASN1_INTEGER(params->u, NULL);
+
+    // Создание стека ASN1_INTEGER для Q и N
+    params_asn1->Q = sk_ASN1_INTEGER_new_null();
+    params_asn1->N = sk_ASN1_INTEGER_new_null();
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *q_elem = BN_to_ASN1_INTEGER(params->Q[i], NULL);
+        ASN1_INTEGER *n_elem = BN_to_ASN1_INTEGER(params->N[i], NULL);
+        sk_ASN1_INTEGER_push(params_asn1->Q, q_elem);
+        sk_ASN1_INTEGER_push(params_asn1->N, n_elem);
+    }
+
+    return params_asn1;
+}
+
+// Функция преобразования HDLP_PUBLIC_KEY в ASN1 структуру
+HDLP_PUBLIC_KEY_ASN1 *hdlp_pub_key2hdlp_pub_key_asn1(HDLP_PUBLIC_KEY *pub_key) {
+    HDLP_PUBLIC_KEY_ASN1 *pub_key_asn1 = OPENSSL_zalloc(sizeof(HDLP_PUBLIC_KEY_ASN1));
+    if (!pub_key_asn1) return NULL;
+
+    // Инициализация ASN1_INTEGER и преобразование BIGNUM в ASN1_INTEGER
+    pub_key_asn1->p = BN_to_ASN1_INTEGER(pub_key->p, NULL);
+    pub_key_asn1->u = BN_to_ASN1_INTEGER(pub_key->u, NULL);
+
+    // Создание стека ASN1_INTEGER для Q, N, Y
+    pub_key_asn1->Q = sk_ASN1_INTEGER_new_null();
+    pub_key_asn1->N = sk_ASN1_INTEGER_new_null();
+    pub_key_asn1->Y = sk_ASN1_INTEGER_new_null();
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *q_elem = BN_to_ASN1_INTEGER(pub_key->Q[i], NULL);
+        ASN1_INTEGER *n_elem = BN_to_ASN1_INTEGER(pub_key->N[i], NULL);
+        ASN1_INTEGER *y_elem = BN_to_ASN1_INTEGER(pub_key->Y[i], NULL);
+        sk_ASN1_INTEGER_push(pub_key_asn1->Q, q_elem);
+        sk_ASN1_INTEGER_push(pub_key_asn1->N, n_elem);
+        sk_ASN1_INTEGER_push(pub_key_asn1->Y, y_elem);
+    }
+
+    return pub_key_asn1;
+}
+
+// Функция преобразования HDLP_PRIVATE_KEY в ASN1 структуру
+HDLP_PRIVATE_KEY_ASN1 *hdlp_priv_key2hdlp_priv_key_asn1(HDLP_PRIVATE_KEY *priv_key) {
+    HDLP_PRIVATE_KEY_ASN1 *priv_key_asn1 = OPENSSL_zalloc(sizeof(HDLP_PRIVATE_KEY_ASN1));
+    if (!priv_key_asn1) return NULL;
+
+    // Инициализация ASN1_INTEGER и преобразование BIGNUM в ASN1_INTEGER
+    priv_key_asn1->x = BN_to_ASN1_INTEGER(priv_key->x, NULL);
+    priv_key_asn1->t = BN_to_ASN1_INTEGER(priv_key->t, NULL);
+
+    return priv_key_asn1;
+}
+
+// Функция преобразования HDLP_SECRET в ASN1 структуру
+HDLP_SECRET_ASN1 *hdlp_secret2hdlp_secret_asn1(HDLP_SECRET *secret) {
+    HDLP_SECRET_ASN1 *secret_asn1 = OPENSSL_zalloc(sizeof(HDLP_SECRET_ASN1));
+    if (!secret_asn1) return NULL;
+
+    // Создание стека ASN1_INTEGER для Z
+    secret_asn1->Z = sk_ASN1_INTEGER_new_null();
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *z_elem = BN_to_ASN1_INTEGER(secret->Z[i], NULL);
+        sk_ASN1_INTEGER_push(secret_asn1->Z, z_elem);
+    }
+
+    return secret_asn1;
+}
+
+// Функция преобразования ASN1-структуры в HDLP_PARAMS
+HDLP_PARAMS *hdlp_params_asn12hdlp_params(HDLP_PARAMS_ASN1 *params_asn1) {
+    HDLP_PARAMS *params = OPENSSL_zalloc(sizeof(HDLP_PARAMS));
+    if (!params) return NULL;
+
+    // Преобразование ASN1_INTEGER в BIGNUM
+    params->p = ASN1_INTEGER_to_BN(params_asn1->p, NULL);
+    params->u = ASN1_INTEGER_to_BN(params_asn1->u, NULL);
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        params->Q[i] = ASN1_INTEGER_to_BN(sk_ASN1_INTEGER_value(params_asn1->Q, i), NULL);
+        params->N[i] = ASN1_INTEGER_to_BN(sk_ASN1_INTEGER_value(params_asn1->N, i), NULL);
+    }
+
+    return params;
+}
+
+// Функция преобразования ASN1-структуры в HDLP_PUBLIC_KEY
+HDLP_PUBLIC_KEY *hdlp_pub_key_asn12hdlp_pub_key(HDLP_PUBLIC_KEY_ASN1 *pub_key_asn1) {
+    HDLP_PUBLIC_KEY *pub_key = OPENSSL_zalloc(sizeof(HDLP_PUBLIC_KEY));
+    if (!pub_key) return NULL;
+
+    // Преобразование ASN1_INTEGER в BIGNUM
+    pub_key->p = ASN1_INTEGER_to_BN(pub_key_asn1->p, NULL);
+    pub_key->u = ASN1_INTEGER_to_BN(pub_key_asn1->u, NULL);
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        pub_key->Q[i] = ASN1_INTEGER_to_BN(sk_ASN1_INTEGER_value(pub_key_asn1->Q, i), NULL);
+        pub_key->N[i] = ASN1_INTEGER_to_BN(sk_ASN1_INTEGER_value(pub_key_asn1->N, i), NULL);
+        pub_key->Y[i] = ASN1_INTEGER_to_BN(sk_ASN1_INTEGER_value(pub_key_asn1->Y, i), NULL);
+    }
+
+    return pub_key;
+}
+
+// Функция преобразования ASN1-структуры в HDLP_PRIVATE_KEY
+HDLP_PRIVATE_KEY *hdlp_priv_key_asn12hdlp_priv_key(HDLP_PRIVATE_KEY_ASN1 *priv_key_asn1) {
+    HDLP_PRIVATE_KEY *priv_key = OPENSSL_zalloc(sizeof(HDLP_PRIVATE_KEY));
+    if (!priv_key) return NULL;
+
+    // Преобразование ASN1_INTEGER в BIGNUM
+    priv_key->x = ASN1_INTEGER_to_BN(priv_key_asn1->x, NULL);
+    priv_key->t = ASN1_INTEGER_to_BN(priv_key_asn1->t, NULL);
+
+    return priv_key;
+}
+
+// Функция преобразования ASN1-структуры в HDLP_SECRET
+HDLP_SECRET *hdlp_secret_asn12hdlp_secret(HDLP_SECRET_ASN1 *secret_asn1) {
+    HDLP_SECRET *secret = OPENSSL_zalloc(sizeof(HDLP_SECRET));
+    if (!secret) return NULL;
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        secret->Z[i] = ASN1_INTEGER_to_BN(sk_ASN1_INTEGER_value(secret_asn1->Z, i), NULL);
+    }
+
+    return secret;
+}
+
+// Функция, которая кодирует HDLP_PARAMS_ASN1 в формат DER
+int i2d_HDLP_PARAMS_ASN1(HDLP_PARAMS_ASN1 *params_asn1, unsigned char **out) {
+    int total_len = 0;
+    unsigned char *buf = NULL, *p;
+
+    if (params_asn1 == NULL) return 0;
+
+    // Calculate the length needed to encode each part of HDLP_PARAMS_ASN1.
+    int len_p = i2d_ASN1_INTEGER(params_asn1->p, NULL);
+    int len_u = i2d_ASN1_INTEGER(params_asn1->u, NULL);
+
+    // Calculate length for STACK_OF(ASN1_INTEGER) Q and N
+    int len_Q = 0, len_N = 0;
+    for (int i = 0; i < sk_ASN1_INTEGER_num(params_asn1->Q); i++) {
+        ASN1_INTEGER *q = sk_ASN1_INTEGER_value(params_asn1->Q, i);
+        len_Q += i2d_ASN1_INTEGER(q, NULL);
+    }
+    for (int i = 0; i < sk_ASN1_INTEGER_num(params_asn1->N); i++) {
+        ASN1_INTEGER *n = sk_ASN1_INTEGER_value(params_asn1->N, i);
+        len_N += i2d_ASN1_INTEGER(n, NULL);
+    }
+
+    // Calculate total length for the entire structure
+    total_len = len_p + len_u + len_Q + len_N;
+
+    // Allocate memory for the buffer
+    buf = OPENSSL_malloc(total_len);
+    if (buf == NULL) return 0;
+    p = buf;
+
+    // Encode each part into the buffer
+    i2d_ASN1_INTEGER(params_asn1->p, &p);
+    i2d_ASN1_INTEGER(params_asn1->u, &p);
+
+    // Encode Q stack
+    for (int i = 0; i < sk_ASN1_INTEGER_num(params_asn1->Q); i++) {
+        ASN1_INTEGER *q = sk_ASN1_INTEGER_value(params_asn1->Q, i);
+        i2d_ASN1_INTEGER(q, &p);
+    }
+
+    // Encode N stack
+    for (int i = 0; i < sk_ASN1_INTEGER_num(params_asn1->N); i++) {
+        ASN1_INTEGER *n = sk_ASN1_INTEGER_value(params_asn1->N, i);
+        i2d_ASN1_INTEGER(n, &p);
+    }
+
+    *out = buf; // Set the output buffer to point to the allocated and filled buffer
+    return total_len;
+}
+
+// Функция, которая кодирует HDLP_PUBLIC_KEY_ASN1 в формат DER
+int i2d_HDLP_PUBLIC_KEY_ASN1(HDLP_PUBLIC_KEY_ASN1 *pub_key_asn1, unsigned char **out) {
+    int total_len = 0;
+    unsigned char *buf = NULL, *p;
+
+    if (pub_key_asn1 == NULL) return 0;
+
+    int len_p = i2d_ASN1_INTEGER(pub_key_asn1->p, NULL);
+    int len_u = i2d_ASN1_INTEGER(pub_key_asn1->u, NULL);
+
+    int len_Q = 0, len_N = 0, len_Y = 0;
+    for (int i = 0; i < sk_ASN1_INTEGER_num(pub_key_asn1->Q); i++) {
+        ASN1_INTEGER *q = sk_ASN1_INTEGER_value(pub_key_asn1->Q, i);
+        len_Q += i2d_ASN1_INTEGER(q, NULL);
+    }
+    for (int i = 0; i < sk_ASN1_INTEGER_num(pub_key_asn1->N); i++) {
+        ASN1_INTEGER *n = sk_ASN1_INTEGER_value(pub_key_asn1->N, i);
+        len_N += i2d_ASN1_INTEGER(n, NULL);
+    }
+    for (int i = 0; i < sk_ASN1_INTEGER_num(pub_key_asn1->Y); i++) {
+        ASN1_INTEGER *y = sk_ASN1_INTEGER_value(pub_key_asn1->Y, i);
+        len_Y += i2d_ASN1_INTEGER(y, NULL);
+    }
+
+    // Calculate total length for the entire structure
+    total_len = len_p + len_u + len_Q + len_N + len_Y;
+
+    // Allocate memory for the buffer
+    buf = OPENSSL_malloc(total_len);
+    if (buf == NULL) return 0;
+    p = buf;
+
+    // Encode each part into the buffer
+    i2d_ASN1_INTEGER(pub_key_asn1->p, &p);
+    i2d_ASN1_INTEGER(pub_key_asn1->u, &p);
+
+    // Encode Q stack
+    for (int i = 0; i < sk_ASN1_INTEGER_num(pub_key_asn1->Q); i++) {
+        ASN1_INTEGER *q = sk_ASN1_INTEGER_value(pub_key_asn1->Q, i);
+        i2d_ASN1_INTEGER(q, &p);
+    }
+
+    // Encode N stack
+    for (int i = 0; i < sk_ASN1_INTEGER_num(pub_key_asn1->N); i++) {
+        ASN1_INTEGER *n = sk_ASN1_INTEGER_value(pub_key_asn1->N, i);
+        i2d_ASN1_INTEGER(n, &p);
+    }
+
+    // Encode Y stack
+    for (int i = 0; i < sk_ASN1_INTEGER_num(pub_key_asn1->Y); i++) {
+        ASN1_INTEGER *y = sk_ASN1_INTEGER_value(pub_key_asn1->Y, i);
+        i2d_ASN1_INTEGER(y, &p);
+    }
+
+    *out = buf; // Set the output buffer to point to the allocated and filled buffer
+    return total_len;
+}
+
+// Функция, которая кодирует HDLP_PRIVATE_KEY_ASN1 в формат DER
+int i2d_HDLP_PRIVATE_KEY_ASN1(HDLP_PRIVATE_KEY_ASN1 *priv_key_asn1, unsigned char **out) {
+    int total_len = 0;
+    unsigned char *buf = NULL, *p;
+
+    if (priv_key_asn1 == NULL) return 0;
+
+    int len_x = i2d_ASN1_INTEGER(priv_key_asn1->x, NULL);
+    int len_t = i2d_ASN1_INTEGER(priv_key_asn1->t, NULL);
+
+    // Calculate total length for the entire structure
+    total_len = len_x + len_t;
+
+    // Allocate memory for the buffer
+    buf = OPENSSL_malloc(total_len);
+    if (buf == NULL) return 0;
+    p = buf;
+
+    // Encode each part into the buffer
+    i2d_ASN1_INTEGER(priv_key_asn1->x, &p);
+    i2d_ASN1_INTEGER(priv_key_asn1->t, &p);
+
+    *out = buf; // Set the output buffer to point to the allocated and filled buffer
+    return total_len;
+}
+
+// Функция, которая кодирует HDLP_SECRET_ASN1 в формат DER
+int i2d_HDLP_SECRET_ASN1(HDLP_SECRET_ASN1 *secret_asn1, unsigned char **out) {
+    unsigned char *buf = NULL, *p;
+
+    if (secret_asn1 == NULL) return 0;
+
+    // Calculate length for STACK_OF(ASN1_INTEGER) Q and N
+    int len_Z = 0;
+    for (int i = 0; i < sk_ASN1_INTEGER_num(secret_asn1->Z); i++) {
+        ASN1_INTEGER *z = sk_ASN1_INTEGER_value(secret_asn1->Z, i);
+        len_Z += i2d_ASN1_INTEGER(z, NULL);
+    }
+
+    // Allocate memory for the buffer
+    buf = OPENSSL_malloc(len_Z);
+    if (buf == NULL) return 0;
+    p = buf;
+
+    // Encode Z stack
+    for (int i = 0; i < sk_ASN1_INTEGER_num(secret_asn1->Z); i++) {
+        ASN1_INTEGER *z = sk_ASN1_INTEGER_value(secret_asn1->Z, i);
+        i2d_ASN1_INTEGER(z, &p);
+    }
+
+    *out = buf; // Set the output buffer to point to the allocated and filled buffer
+    return len_Z;
+}
+
+// Функция, которая декодирует данные в формате DER обратно в структуру HDLP_PARAMS_ASN1.
+HDLP_PARAMS_ASN1 *d2i_HDLP_PARAMS_ASN1(const unsigned char **in, long len) {
+    const unsigned char *p = *in;
+    HDLP_PARAMS_ASN1 *new_params_asn1 = HDLP_PARAMS_ASN1_new();
+    if (new_params_asn1 == NULL) return NULL;
+
+    // Декодирование p
+    new_params_asn1->p = d2i_ASN1_INTEGER(NULL, &p, len);
+    if (new_params_asn1->p == NULL) goto err;
+    len -= p - *in; // Обновляем длину оставшихся данных
+    *in = p;         // Обновляем указатель данных
+
+    // Декодирование u
+    new_params_asn1->u = d2i_ASN1_INTEGER(NULL, &p, len);
+    if (new_params_asn1->u == NULL) goto err;
+    len -= p - *in;
+    *in = p;
+
+    // Декодирование Q
+    new_params_asn1->Q = sk_ASN1_INTEGER_new_null();
+    if (new_params_asn1->Q == NULL) goto err;
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *q = d2i_ASN1_INTEGER(NULL, &p, len);
+        if (q == NULL) goto err;
+        sk_ASN1_INTEGER_push(new_params_asn1->Q, q);
+        len -= p - *in;
+        *in = p;
+    }
+
+    // Декодирование N
+    new_params_asn1->N = sk_ASN1_INTEGER_new_null();
+    if (new_params_asn1->N == NULL) goto err;
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *n = d2i_ASN1_INTEGER(NULL, &p, len);
+        if (n == NULL) goto err;
+        sk_ASN1_INTEGER_push(new_params_asn1->N, n);
+        len -= p - *in;
+        *in = p;
+    }
+
+    *in = p; // Обновляем `*in` на позицию после последнего декодированного объекта
+    return new_params_asn1;
+
+err:
+    if (new_params_asn1) HDLP_PARAMS_ASN1_free(new_params_asn1);
+    return NULL;
+}
+
+// Функция, которая декодирует данные в формате DER обратно в структуру HDLP_PUBLIC_KEY_ASN1.
+HDLP_PUBLIC_KEY_ASN1 *d2i_HDLP_PUBLIC_KEY_ASN1(const unsigned char **in, long len) {
+    const unsigned char *p = *in;
+    HDLP_PUBLIC_KEY_ASN1 *new_pub_key_asn1 = HDLP_PUBLIC_KEY_ASN1_new();
+    if (new_pub_key_asn1 == NULL) return NULL;
+
+    // Декодирование p
+    new_pub_key_asn1->p = d2i_ASN1_INTEGER(NULL, &p, len);
+    if (new_pub_key_asn1->p == NULL) goto err;
+    len -= p - *in; // Обновляем длину оставшихся данных
+    *in = p;         // Обновляем указатель данных
+
+    // Декодирование u
+    new_pub_key_asn1->u = d2i_ASN1_INTEGER(NULL, &p, len);
+    if (new_pub_key_asn1->u == NULL) goto err;
+    len -= p - *in;
+    *in = p;
+
+    // Декодирование Q
+    new_pub_key_asn1->Q = sk_ASN1_INTEGER_new_null();
+    if (new_pub_key_asn1->Q == NULL) goto err;
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *q = d2i_ASN1_INTEGER(NULL, &p, len);
+        if (q == NULL) goto err;
+        sk_ASN1_INTEGER_push(new_pub_key_asn1->Q, q);
+        len -= p - *in;
+        *in = p;
+    }
+
+    // Декодирование N
+    new_pub_key_asn1->N = sk_ASN1_INTEGER_new_null();
+    if (new_pub_key_asn1->N == NULL) goto err;
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *n = d2i_ASN1_INTEGER(NULL, &p, len);
+        if (n == NULL) goto err;
+        sk_ASN1_INTEGER_push(new_pub_key_asn1->N, n);
+        len -= p - *in;
+        *in = p;
+    }
+
+    // Декодирование Y
+    new_pub_key_asn1->Y = sk_ASN1_INTEGER_new_null();
+    if (new_pub_key_asn1->Y == NULL) goto err;
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *y = d2i_ASN1_INTEGER(NULL, &p, len);
+        if (y == NULL) goto err;
+        sk_ASN1_INTEGER_push(new_pub_key_asn1->Y, y);
+        len -= p - *in;
+        *in = p;
+    }
+
+    *in = p; // Обновляем `*in` на позицию после последнего декодированного объекта
+    return new_pub_key_asn1;
+
+err:
+    if (new_pub_key_asn1) HDLP_PUBLIC_KEY_ASN1_free(new_pub_key_asn1);
+    return NULL;
+}
+
+// Функция, которая декодирует данные в формате DER обратно в структуру HDLP_PRIVATE_KEY_ASN1.
+HDLP_PRIVATE_KEY_ASN1 *d2i_HDLP_PRIVATE_KEY_ASN1(const unsigned char **in, long len) {
+    const unsigned char *p = *in;
+    HDLP_PRIVATE_KEY_ASN1 *new_priv_key_asn1 = HDLP_PRIVATE_KEY_ASN1_new();
+    if (new_priv_key_asn1 == NULL) return NULL;
+
+    // Декодирование x
+    new_priv_key_asn1->x = d2i_ASN1_INTEGER(NULL, &p, len);
+    if (new_priv_key_asn1->x == NULL) goto err;
+    len -= p - *in; // Обновляем длину оставшихся данных
+    *in = p;         // Обновляем указатель данных
+
+    // Декодирование t
+    new_priv_key_asn1->t = d2i_ASN1_INTEGER(NULL, &p, len);
+    if (new_priv_key_asn1->t == NULL) goto err;
+    len -= p - *in;
+    *in = p;
+
+    *in = p; // Обновляем `*in` на позицию после последнего декодированного объекта
+    return new_priv_key_asn1;
+
+err:
+    if (new_priv_key_asn1) HDLP_PRIVATE_KEY_ASN1_free(new_priv_key_asn1);
+    return NULL;
+}
+
+// Функция, которая декодирует данные в формате DER обратно в структуру HDLP_SECRET_ASN1.
+HDLP_SECRET_ASN1 *d2i_HDLP_SECRET_ASN1(const unsigned char **in, long len) {
+    const unsigned char *p = *in;
+    HDLP_SECRET_ASN1 *new_secret_asn1 = HDLP_SECRET_ASN1_new();
+    if (new_secret_asn1 == NULL) return NULL;
+
+    // Декодирование Z
+    new_secret_asn1->Z = sk_ASN1_INTEGER_new_null();
+    if (new_secret_asn1->Z == NULL) goto err;
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *z = d2i_ASN1_INTEGER(NULL, &p, len);
+        if (z == NULL) goto err;
+        sk_ASN1_INTEGER_push(new_secret_asn1->Z, z);
+        len -= p - *in;
+        *in = p;
+    }
+
+    *in = p; // Обновляем `*in` на позицию после последнего декодированного объекта
+    return new_secret_asn1;
+
+err:
+    if (new_secret_asn1) HDLP_SECRET_ASN1_free(new_secret_asn1);
+    return NULL;
+}
+
+int encode_hdlp_params(HDLP_PARAMS *params, unsigned char **data) {
+    int len;
+    HDLP_PARAMS_ASN1 *asn1_params = HDLP_PARAMS_ASN1_new();
+    asn1_params = hdlp_params2hdlp_params_asn1(params); // Преобразование в ASN1-структуру
+    if (asn1_params == NULL) return 0;
+
+    len = i2d_HDLP_PARAMS_ASN1(asn1_params, data); // Кодирование структуры в DER
+    HDLP_PARAMS_ASN1_free(asn1_params); // Освобождение ресурсов
+
+    return len; // Возвращаем длину данных
+}
+
+int encode_hdlp_pub_key(HDLP_PUBLIC_KEY *pub_key, unsigned char **data) {
+    int len;
+    HDLP_PUBLIC_KEY_ASN1 *asn1_pub_key = HDLP_PUBLIC_KEY_ASN1_new();
+    asn1_pub_key = hdlp_pub_key2hdlp_pub_key_asn1(pub_key); // Преобразование в ASN1-структуру
+    if (asn1_pub_key == NULL) return 0;
+
+    len = i2d_HDLP_PUBLIC_KEY_ASN1(asn1_pub_key, data); // Кодирование структуры в DER
+    
+    HDLP_PUBLIC_KEY_ASN1_free(asn1_pub_key); // Освобождение ресурсов
+
+    return len; // Возвращаем длину данных
+}
+
+int encode_hdlp_priv_key(HDLP_PRIVATE_KEY *priv_key, unsigned char **data) {
+    int len;
+    HDLP_PRIVATE_KEY_ASN1 *asn1_priv_key = HDLP_PRIVATE_KEY_ASN1_new();
+    asn1_priv_key = hdlp_priv_key2hdlp_priv_key_asn1(priv_key); // Преобразование в ASN1-структуру
+    if (asn1_priv_key == NULL) return 0;
+
+    len = i2d_HDLP_PRIVATE_KEY_ASN1(asn1_priv_key, data); // Кодирование структуры в DER
+    
+    HDLP_PRIVATE_KEY_ASN1_free(asn1_priv_key); // Освобождение ресурсов
+
+    return len; // Возвращаем длину данных
+}
+
+int encode_hdlp_secret(HDLP_SECRET *secret, unsigned char **data) {
+    int len;
+    HDLP_SECRET_ASN1 *asn1_secret = HDLP_SECRET_ASN1_new();
+    asn1_secret = hdlp_secret2hdlp_secret_asn1(secret); // Преобразование в ASN1-структуру
+    if (asn1_secret == NULL) return 0;
+
+    len = i2d_HDLP_SECRET_ASN1(asn1_secret, data); // Кодирование структуры в DER
+    HDLP_SECRET_ASN1_free(asn1_secret); // Освобождение ресурсов
+
+    return len; // Возвращаем длину данных
+}
+
+HDLP_PARAMS *decode_hdlp_params(const unsigned char *data, long len) {
+    
+    HDLP_PARAMS_ASN1 *asn1_params = HDLP_PARAMS_ASN1_new();
+    HDLP_PARAMS *decoded_params = HDLP_PARAMS_new();
+
+    const unsigned char *p = data;  // Указатель на начало данных
+    
+    asn1_params = d2i_HDLP_PARAMS_ASN1(&p, len);
+
+    decoded_params = hdlp_params_asn12hdlp_params(asn1_params); // Преобразование в HDLP_PARAMS
+
+    HDLP_PARAMS_ASN1_free(asn1_params); // Освобождение ресурсов
+
+    return decoded_params; // Возвращаем успех или неудачу
+}
+
+HDLP_PUBLIC_KEY *decode_hdlp_pub_key(const unsigned char *data, long len) {
+    
+    HDLP_PUBLIC_KEY_ASN1 *asn1_pub_key = HDLP_PUBLIC_KEY_ASN1_new();
+    HDLP_PUBLIC_KEY *decoded_pub_key = HDLP_PUBLIC_KEY_new();
+
+    const unsigned char *p = data;  // Указатель на начало данных
+    
+    asn1_pub_key = d2i_HDLP_PUBLIC_KEY_ASN1(&p, len); // -----------------------------------------------------
+
+    decoded_pub_key = hdlp_pub_key_asn12hdlp_pub_key(asn1_pub_key); // Преобразование в HDLP_PUBLIC_KEY
+
+    HDLP_PUBLIC_KEY_ASN1_free(asn1_pub_key); // Освобождение ресурсов
+
+    return decoded_pub_key; // Возвращаем успех или неудачу
+}
+
+HDLP_PRIVATE_KEY *decode_hdlp_priv_key(const unsigned char *data, long len) {
+    
+    HDLP_PRIVATE_KEY_ASN1 *asn1_priv_key = HDLP_PRIVATE_KEY_ASN1_new();
+    HDLP_PRIVATE_KEY *decoded_priv_key = HDLP_PRIVATE_KEY_new();
+
+    const unsigned char *p = data;  // Указатель на начало данных
+    
+    asn1_priv_key = d2i_HDLP_PRIVATE_KEY_ASN1(&p, len); // -----------------------------------------------------
+
+    decoded_priv_key = hdlp_priv_key_asn12hdlp_priv_key(asn1_priv_key); // Преобразование в HDLP_PRIVATE_KEY
+
+    HDLP_PRIVATE_KEY_ASN1_free(asn1_priv_key); // Освобождение ресурсов
+
+    return decoded_priv_key; // Возвращаем успех или неудачу
+}
+
+HDLP_SECRET *decode_hdlp_secret(const unsigned char *data, long len) {
+    
+    HDLP_SECRET_ASN1 *asn1_secret = HDLP_SECRET_ASN1_new();
+    HDLP_SECRET *decoded_secret = HDLP_SECRET_new();
+
+    const unsigned char *p = data;  // Указатель на начало данных
+    
+    asn1_secret = d2i_HDLP_SECRET_ASN1(&p, len);
+
+    decoded_secret = hdlp_secret_asn12hdlp_secret(asn1_secret); // Преобразование в HDLP_SECRET
+
+    HDLP_SECRET_ASN1_free(asn1_secret); // Освобождение ресурсов
+
+    return decoded_secret; // Возвращаем успех или неудачу
+}
+
+// Таблица умножения формальных базисных векторов
+int TYFBV[VECTOR_SIZE][VECTOR_SIZE] = { {0, 3, 0, 3}, {2, 1, 2, 1}, {2, 1, 2, 1}, {0, 3, 0, 3} };
+
+// Расстановка структурных коэффициентов в ТУФБВ
+int coefficient[VECTOR_SIZE][VECTOR_SIZE] = { {1, 0, 0, 1}, {1, 1, 1, 1}, {1, 0, 0, 1}, {1, 1, 1, 1} };
+
+// Операция умножения двух векторов в поле GF(p)
+void multVec(BIGNUM* res[VECTOR_SIZE], BIGNUM* vec_1[VECTOR_SIZE], BIGNUM* vec_2[VECTOR_SIZE], BIGNUM* p, BN_CTX* ctx) {
+    BIGNUM* mul = BN_new();
+    BIGNUM* coeff = BN_new();
+    BIGNUM* vec_temp[VECTOR_SIZE];
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        vec_temp[i] = BN_new();
+        BN_zero(vec_temp[i]);
+    }
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        for (int j = 0; j < VECTOR_SIZE; j++) {
+            BN_mod_mul(mul, vec_1[i], vec_2[j], p, ctx); // mul = (vec1[i] * vec2[j]) % p
+
+            BN_set_word(coeff, coefficient[i][j]);
+            BN_mod_mul(mul, mul, coeff, p, ctx); // mul = (koef[i][j] * vec1[i] * vec2[j]) % p
+ 
+            BN_mod_add(vec_temp[TYFBV[i][j]], vec_temp[TYFBV[i][j]], mul, p, ctx); // res[TYFBV[i][j]] = (res[TYFBV[i][j]] + mul) % p
+        }
+    }
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_copy(res[i], vec_temp[i]);
+        BN_free(vec_temp[i]);
+    }
+
+    BN_free(mul);
+    BN_free(coeff);
+}
+
+// Генерация случайного числа в диапазоне [min, max-1]
+BIGNUM* random_bignum(BIGNUM* min, BIGNUM* max) {
+    BIGNUM* range = BN_new();
+    BIGNUM* rand_num = BN_new();
+
+    BN_sub(range, max, min);           // range = max - min
+    BN_rand_range(rand_num, range);    // rand_num = random number < range
+    BN_add(rand_num, rand_num, min);   // rand_num = rand_num + min
+
+    BN_free(range);
+    return rand_num;
+}
+
+bool arrays_are_equal(BIGNUM* arr_1[VECTOR_SIZE], BIGNUM* arr_2[VECTOR_SIZE]) {
+    // Сравниваем каждый элемент массива
+    for (size_t i = 0; i < VECTOR_SIZE; i++) {
+        if (BN_cmp(arr_1[i], arr_2[i]) != 0) {
+            return false; // Если хотя бы один элемент не равен, возвращаем false
+        }
+    }
+    return true; // Если все элементы равны, возвращаем true
+}
+
+// Генерация обратимого вектора Q и необратимого вектора N, удовлетворяющих условию Q ⚬ N ≠ N ⚬ Q
+void genQN(HDLP_PARAMS *params, BN_CTX* ctx) {
+    
+    BIGNUM* QN[VECTOR_SIZE];
+    BIGNUM* NQ[VECTOR_SIZE];
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        QN[i] = BN_new();
+        NQ[i] = BN_new();
+    }
+
+    BIGNUM* detQ = BN_new();
+    BIGNUM* detN = BN_new();
+    BIGNUM* mul = BN_new();
+    
+    BIGNUM* one = BN_new();
+    BN_one(one);
+    BIGNUM* zero = BN_new();
+    BN_zero(zero);
+
+    do {
+        do {
+            for (int i = 0; i < VECTOR_SIZE; i++) {
+                params->Q[i] = random_bignum(zero, params->p);
+            }
+            BN_mul(detQ, params->Q[3], params->Q[2], ctx);
+            BN_mul(mul, params->Q[0], params->Q[1], ctx);
+            BN_sub(detQ, detQ, mul);
+        } while (BN_is_zero(detQ)); // Условие обратимости: detQ != 0
+
+        do {
+            params->N[0] = random_bignum(one, params->p);
+            params->N[3] = random_bignum(one, params->p);
+            BN_rshift1(params->N[1], params->N[3]);
+            BN_rshift1(params->N[2], params->N[0]);
+            BN_mul(detN, params->N[3], params->N[2], ctx);
+            BN_mul(mul, params->N[0], params->N[1], ctx);
+            BN_sub(detN, detN, mul);
+        } while (!BN_is_zero(detN)); // Условие необратимости: detN == 0
+
+        multVec(QN, params->Q, params->N, params->p, ctx);
+        multVec(NQ, params->N, params->Q, params->p, ctx);
+    } while (arrays_are_equal(QN, NQ));
+
+    BN_free(detQ);
+    BN_free(detN);
+    BN_free(mul);
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_free(QN[i]);
+        BN_free(NQ[i]);
+    }
+}
+
+// Вычисление глобальной единицы E
+void genE(BIGNUM* E[4], BIGNUM* p, BN_CTX* ctx) {
+    // Инициализация элементов массива E
+    for (int i = 0; i < 4; i++) E[i] = BN_new();
+
+    BN_one(E[0]);
+    BN_one(E[1]);
+    BN_sub(E[2], p, BN_value_one());
+    BN_zero(E[3]);
+}
+
+// Функция для возведения вектора степень в поле GF(p)
+void exponentiation(BIGNUM* res[VECTOR_SIZE], BIGNUM* vec[VECTOR_SIZE], BIGNUM* degree, BIGNUM* p, BIGNUM* E[VECTOR_SIZE], BN_CTX* ctx) {
+    BIGNUM* N = BN_new();       // Копия степени
+    BN_copy(N, degree);         // N = degree
+
+    BIGNUM* Y[VECTOR_SIZE];     // Результирующий вектор (начинается с глобальной единицы E)
+    BIGNUM* Z[VECTOR_SIZE];     // Рабочий вектор для возведения в степень
+
+    // Инициализация Y = E и Z = vec
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        Y[i] = BN_new();
+        Z[i] = BN_new();
+        BN_copy(Y[i], E[i]);
+        BN_copy(Z[i], vec[i]);
+    }
+
+    // Основной цикл быстрого возведения в степень
+    while (!BN_is_zero(N)) {
+
+        if (BN_is_odd(N)) {  // Если N нечетное
+            multVec(Y, Y, Z, p, ctx); // Y = Y * Z
+        }
+
+        multVec(Z, Z, Z, p, ctx); // Z = Z * Z
+        BN_rshift1(N, N); // N = N / 2
+    }
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_copy(res[i], Y[i]);
+        BN_free(Y[i]);
+        BN_free(Z[i]);
+    }
+    BN_free(N);
+}
+
+BIGNUM* find_divisor(BIGNUM* order, int choice, BN_CTX* ctx) {
+    BIGNUM* divisor = BN_new();
+    BIGNUM* i = BN_new();
+    BIGNUM* ten = BN_new();
+    BN_set_word(ten, 10);
+    BN_div(i, NULL, order, ten, ctx);
+    int attempts = 0;
+
+    while (BN_cmp(i, BN_value_one()) > 0) {
+        BIGNUM* remainder = BN_new();
+        BN_mod(remainder, order, i, ctx);
+        
+        if (BN_is_zero(remainder)) {
+            BN_free(remainder);
+            BN_copy(divisor, i);
+            BN_free(i);
+            BN_free(ten);
+            return divisor;  // Возвращаем найденный делитель
+        }
+
+        BN_sub(i, i, BN_value_one());  // i--
+        attempts++;
+
+        BN_free(remainder);
+        if (attempts == 1000 && choice == 1) {
+            BN_free(divisor);
+            BN_free(i);
+            BN_free(ten);
+            return NULL;  // Возвращаем NULL, если не нашли делитель
+        }
+    }
+
+    BN_free(divisor);
+    BN_free(i);
+    BN_free(ten);
+    return NULL;  // Возвращаем NULL, если цикл завершился без находки
+}
+
+void calculate_order(BIGNUM* order, BIGNUM* p, BN_CTX* ctx) {
+    BIGNUM* p_square = BN_new();
+
+    BN_sub(order, p, BN_value_one());          // order = P - 1
+    BN_mul(order, p, order, ctx);              // order = P * (P - 1)
+    BN_mul(p_square, p, p, ctx);               // P_square = P * P
+    BN_sub(p_square, p_square, BN_value_one()); // P_square = P * P - 1
+    BN_mul(order, order, p_square, ctx);       // order = P * (P - 1) * (P * P - 1)
+
+    BN_free(p_square);
+}
+
+// Функция генерации параметров
+void gen_HDLP_params(int pSize, HDLP_PARAMS *params, BN_CTX* ctx) {
+    BIGNUM* order = BN_new();
+    BIGNUM* divisor = BN_new();
+    BIGNUM* E[VECTOR_SIZE];
+
+    do{
+        // Генерация большого простого числа p размером pBit бит
+        BN_generate_prime_ex(params->p, pSize, 1, NULL, NULL, NULL);
+
+        // Вычисление порядка некоммутативной мультипликативной группы кольца
+        calculate_order(order, params->p, ctx);
+
+        // Генерация глобальной единицы E
+        genE(E, params->p, ctx);
+
+        // Определение одного из делителей порядка группы
+        divisor = find_divisor(order, 1, ctx);
+    } while (divisor == NULL);
+
+    // Генерация подходящих векторов Q и N
+    BIGNUM* temp[VECTOR_SIZE];
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        temp[i] = BN_new();
+    }
+
+    BIGNUM* q = BN_new();
+
+    // Проверка того, что E является глобальной единицей и поиск Q, для которого порядок равен divisor
+    while (1) {
+        genQN(params, ctx);
+        multVec(temp, params->Q, E, params->p, ctx);
+        if (arrays_are_equal(temp, params->Q)) {
+            multVec(temp, E, params->Q, params->p, ctx);
+            if (arrays_are_equal(temp, params->Q)) {
+                exponentiation(temp, params->Q, divisor, params->p, E, ctx);
+                if (arrays_are_equal(temp, E)) {
+                    BN_copy(q, divisor);
+                    break;
+                }
+            }
+        }
+    }
+
+    // Генерация случайного числа u
+    BIGNUM* zero = BN_new();
+    BN_zero(zero);
+    params->u = BN_new();
+    params->u = random_bignum(zero, q);
+
+    BN_free(q); BN_free(divisor); BN_free(order);
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_free(temp[i]); BN_free(E[i]);
+    }
+}
+
+// Функция, которая проверяет корректность параметров
+bool check_HDLP_params(HDLP_PARAMS *params, BN_CTX* ctx){
+    //p должно быть простым
+    if (!BN_is_prime_ex(params->p, 0, ctx, NULL))
+        return false;
+    
+    //Все элементы должны быть меньше p
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        if (BN_cmp(params->Q[i], params->p) > -1)
+            return false;
+        if (BN_cmp(params->N[i], params->p) > -1)
+            return false;
+    }
+    if (BN_cmp(params->u, params->p) > -1)
+            return false;
+    
+    BIGNUM* E[VECTOR_SIZE];
+    genE(E, params->p, ctx);
+
+    BIGNUM* temp[VECTOR_SIZE];
+    BIGNUM* QN[VECTOR_SIZE];
+    BIGNUM* NQ[VECTOR_SIZE];
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        temp[i] = BN_new();
+        QN[i] = BN_new();
+        NQ[i] = BN_new();
+    }
+
+    //E должна быть глобальной единицей
+    multVec(temp, params->Q, E, params->p, ctx);
+    if (!arrays_are_equal(temp, params->Q))
+        return false;
+    multVec(temp, E, params->Q, params->p, ctx);
+    if (!arrays_are_equal(temp, params->Q))
+        return false;
+
+    BIGNUM* det = BN_new();
+    BIGNUM* mul = BN_new();
+
+    //Q должно быть обратимым
+    BN_mul(det, params->Q[3], params->Q[2], ctx);
+    BN_mul(mul, params->Q[0], params->Q[1], ctx);
+    BN_sub(det, det, mul);
+    if (BN_is_zero(det))
+        return false;
+
+    //N должно быть необратимым
+    BN_mul(det, params->N[3], params->N[2], ctx);
+    BN_mul(mul, params->N[0], params->N[1], ctx);
+    BN_sub(det, det, mul);
+    if (!BN_is_zero(det))
+        return false;
+    
+    //QN не должно быть равно NQ
+    multVec(QN, params->Q, params->N, params->p, ctx);
+    multVec(NQ, params->N, params->Q, params->p, ctx);
+    if (arrays_are_equal(QN, NQ))
+        return false;
+
+    return true;
+}
+
+// Функция, которая считывает параметры из файла
+HDLP_PARAMS *read_HDLP_params(char *infile, int informat){
+
+    BIO *in = bio_open_default(infile, 'r', informat);
+
+    if (in == NULL){
+        BIO_printf(bio_err, "Error, the input file %s could not be read\n", infile);
+        return NULL;
+    }    
+    
+    unsigned char *data = NULL;
+    char *name = "HDLP Parameters", *header = NULL;
+    long len;
+
+    if (informat == FORMAT_PEM) {
+
+        // PEM
+        if (!PEM_read_bio(in, &name, &header, &data, &len))
+            return NULL;
+        
+    } else if (informat == FORMAT_ASN1){
+
+        // Определяем длину файла
+        FILE *fp = fopen(infile, "rb");
+        if (!fp)
+            return NULL;
+
+        fseek(fp, 0, SEEK_END);
+        len = ftell(fp);     
+        rewind(fp);               
+        fclose(fp);               
+
+        if (len == NULL)
+            return NULL;
+
+        // Выделяем память для содержимого файла
+        data = (unsigned char *)malloc(len);
+            
+        // Считываем содержимое файла
+        if (BIO_read(in, data, len) != len)
+            return NULL;
+        
+    }
+    
+    return decode_hdlp_params(data, len); // Декодирование параметров
+}
+
+// Функция, которая считывает открытый ключ из файла
+HDLP_PUBLIC_KEY *read_HDLP_public_key(char *infile, int informat){
+
+    BIO *in = bio_open_default(infile, 'r', informat);
+
+    if (in == NULL){
+        BIO_printf(bio_err, "Error, the input file %s could not be read\n", infile);
+        return NULL;
+    }    
+    
+    unsigned char *data = NULL;
+    char *name = "HDLP PUBLIC KEY", *header = NULL;
+    long len;
+
+    if (informat == FORMAT_PEM) {
+
+        // PEM
+        if (!PEM_read_bio(in, &name, &header, &data, &len))
+            return NULL;
+        
+    } else if (informat == FORMAT_ASN1){
+
+        // Определяем длину файла
+        FILE *fp = fopen(infile, "rb");
+        if (!fp)
+            return NULL;
+
+        fseek(fp, 0, SEEK_END);
+        len = ftell(fp);     
+        rewind(fp);               
+        fclose(fp);               
+
+        if (len == NULL)
+            return NULL;
+
+        // Выделяем память для содержимого файла
+        data = (unsigned char *)malloc(len);
+            
+        // Считываем содержимое файла
+        if (BIO_read(in, data, len) != len)
+            return NULL;
+        
+    }
+    
+    return decode_hdlp_pub_key(data, len); // Декодирование открытого ключа
+}
+
+// Функция, которая считывает закрытый ключ из файла
+HDLP_PRIVATE_KEY *read_HDLP_private_key(char *infile, int informat){
+
+    BIO *in = bio_open_default(infile, 'r', informat);
+
+    if (in == NULL){
+        BIO_printf(bio_err, "Error, the input file %s could not be read\n", infile);
+        return NULL;
+    }    
+    
+    unsigned char *data = NULL;
+    char *name = "HDLP PRIVATE KEY", *header = NULL;
+    long len;
+
+    if (informat == FORMAT_PEM) {
+
+        // PEM
+        if (!PEM_read_bio(in, &name, &header, &data, &len))
+            return NULL;
+        
+    } else if (informat == FORMAT_ASN1){
+
+        // Определяем длину файла
+        FILE *fp = fopen(infile, "rb");
+        if (!fp)
+            return NULL;
+
+        fseek(fp, 0, SEEK_END);
+        len = ftell(fp);     
+        rewind(fp);               
+        fclose(fp);               
+
+        if (len == NULL)
+            return NULL;
+
+        // Выделяем память для содержимого файла
+        data = (unsigned char *)malloc(len);
+            
+        // Считываем содержимое файла
+        if (BIO_read(in, data, len) != len)
+            return NULL;
+        
+    }
+    
+    return decode_hdlp_priv_key(data, len); // Декодирование закрытого ключа
+}
+
+// Функция генерации ключей
+void gen_HDLP_keys(HDLP_PUBLIC_KEY *pub_key, HDLP_PRIVATE_KEY *priv_key, HDLP_PARAMS *params, BN_CTX *ctx) {
+    BIGNUM *order = BN_new();
+    BIGNUM *q = BN_new();
+    BIGNUM *diff_qu = BN_new();
+    BIGNUM *diff_ut = BN_new();
+    
+    BIGNUM *F[VECTOR_SIZE];
+    BIGNUM *temp[VECTOR_SIZE];
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        F[i] = BN_new();
+        temp[i] = BN_new();
+    }
+    BIGNUM *E[VECTOR_SIZE];
+    genE(E, params->p, ctx);
+    // Вычисляем порядок группы
+    calculate_order(order, params->p, ctx);
+
+    // Находим делитель порядка группы
+    do {
+        q = find_divisor(order, 0, ctx);
+    } while (BN_cmp(q, params->u) < 1);
+
+    BN_sub(diff_qu, q, params->u);
+    exponentiation(F, params->Q, diff_qu, params->p, E, ctx);
+    multVec(F, F, E, params->p, ctx);
+
+    // Генерация случайных значений t и x
+    BIGNUM *zero = BN_new(); 
+    BN_zero(zero); 
+    BIGNUM *two = BN_new();
+    BN_set_word(two, 2);
+
+    priv_key->t = random_bignum(zero, params->u);
+    priv_key->x = random_bignum(two, params->p);
+
+    // Вычисление Y = Q^(u - t) ⚬ F ⚬ N^(x) ⚬ Q^(t)
+    BN_sub(diff_ut, params->u, priv_key->t);
+    exponentiation(temp, params->Q, diff_ut, params->p, E, ctx);
+    multVec(pub_key->Y, temp, F, params->p, ctx);
+    exponentiation(temp, params->N, priv_key->x, params->p, E, ctx);
+    multVec(pub_key->Y, pub_key->Y, temp, params->p, ctx);
+    exponentiation(temp, params->Q, priv_key->t, params->p, E, ctx);
+    multVec(pub_key->Y, pub_key->Y, temp, params->p, ctx);
+
+    pub_key->u = params->u;
+    pub_key->p = params->p;
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        pub_key->Q[i] = params->Q[i]; 
+        pub_key->N[i] = params->N[i];
+        BN_free(F[i]);
+        BN_free(temp[i]);
+        BN_free(E[i]);
+    }
+    BN_free(diff_qu);
+    BN_free(diff_ut);
+    BN_free(order);
+    BN_free(q);
+    BN_free(zero);
+    BN_free(two);
+}
+
+// Функция, которая выводит параметры на экран
+void print_HDLP_params(HDLP_PARAMS *params, int num){
+
+    if (num == 0)
+            BIO_printf(bio_err, "HDLP Parameters:\n");
+    else
+        BIO_printf(bio_err, "HDLP Parameters (%d bit):\n", num);
+
+    BIO_printf(bio_err, "   Q = {");
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BIO_printf(bio_err, "%s", BN_bn2dec(params->Q[i]));
+        
+        if (i != VECTOR_SIZE - 1) {
+            BIO_printf(bio_err, ",\n        ");
+        }
+    }
+    BIO_printf(bio_err, "}\n");
+
+    BIO_printf(bio_err, "\n   N = {");
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BIO_printf(bio_err, "%s", BN_bn2dec(params->N[i]));
+        
+        if (i != VECTOR_SIZE - 1) {
+            BIO_printf(bio_err, ",\n        ");
+        }
+    }
+    printf("}\n");
+
+    BIO_printf(bio_err, "\n   p = %s \n", BN_bn2dec(params->p));
+    BIO_printf(bio_err, "\n   u = %s \n", BN_bn2dec(params->u));
+
+}
+
+// Функция, которая выводит открытый ключ на экран
+void print_HDLP_PUBLIC_KEY(HDLP_PUBLIC_KEY *pub_key){
+
+    BIO_printf(bio_err, "\nHDLP public-key:\n");
+
+    BIO_printf(bio_err, "   Y = {");
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BIO_printf(bio_err, "%s", BN_bn2dec(pub_key->Y[i]));
+        
+        if (i != VECTOR_SIZE - 1) {
+            BIO_printf(bio_err, ",\n        ");
+        }
+    }
+    BIO_printf(bio_err, "}\n");
+    
+}
+
+// Функция, которая выводит закрытый ключ на экран
+void print_HDLP_PRIVATE_KEY(HDLP_PRIVATE_KEY *priv_key){
+
+    BIO_printf(bio_err, "\nHDLP private-key:\n");
+
+    BIO_printf(bio_err, "   t = %s \n", BN_bn2dec(priv_key->t));
+    BIO_printf(bio_err, "   x = %s \n", BN_bn2dec(priv_key->x));
+    
+}
+
+// Функция, которая генерирует секрет
+HDLP_SECRET * genSecret(HDLP_PUBLIC_KEY* pub_key, HDLP_PRIVATE_KEY *priv_key, BN_CTX* ctx) {
+    BIGNUM* E[VECTOR_SIZE]; // Массив для глобальной единицы E
+    HDLP_SECRET *secret = HDLP_SECRET_new();
+    BIGNUM* temp_1[VECTOR_SIZE];
+    BIGNUM* temp_2[VECTOR_SIZE];
+    BIGNUM* diff_ut = BN_new(); // Переменная для u - t
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        temp_1[i] = BN_new();
+        temp_2[i] = BN_new();
+    }
+    // Генерация глобальной единицы E
+    genE(E, pub_key->p, ctx);
+    
+    // Вычисление u - t
+    BN_sub(diff_ut, pub_key->u, priv_key->t);
+
+    // Вычисление Q^(u - t)
+    exponentiation(temp_1, pub_key->Q, diff_ut, pub_key->p, E, ctx);
+    
+    // Вычисление Y^x
+    exponentiation(temp_2, pub_key->Y, priv_key->x, pub_key->p, E, ctx);
+
+    // Вычисление Z = Q^(u - t) ⚬ Y^x
+    multVec(secret->Z, temp_1, temp_2, pub_key->p, ctx);
+    
+    // Вычисление Q^t
+    exponentiation(temp_1, pub_key->Q, priv_key->t, pub_key->p, E, ctx);
+    
+    // Вычисление Z = Z ⚬ Q^t
+    multVec(secret->Z, secret->Z, temp_1, pub_key->p, ctx);
+
+    // Очистка памяти
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_free(E[i]);
+        BN_free(temp_1[i]);
+        BN_free(temp_2[i]);
+    }
+    BN_free(diff_ut);
+
+    return secret;
+}
+
+// Функция, которая выводит секрет на экран
+void print_HDLP_SECRET(HDLP_SECRET *secret){
+
+    BIO_printf(bio_err, "\nHDLP secret:\n");
+
+    BIO_printf(bio_err, "   Z = {");
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BIO_printf(bio_err, "%s", BN_bn2dec(secret->Z[i]));
+        
+        if (i != VECTOR_SIZE - 1) {
+            BIO_printf(bio_err, ",\n        ");
+        }
+    }
+    BIO_printf(bio_err, "}\n");
+    
+}
diff --git a/apps/hdlpparam.c b/apps/hdlpparam.c
new file mode 100644
index 0000000..4c64c8a
--- /dev/null
+++ b/apps/hdlpparam.c
@@ -0,0 +1,196 @@
+#include <openssl/opensslconf.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <string.h>
+#include "apps.h"
+#include "progs.h"
+#include <string.h>
+#include <locale.h>
+#include <stdbool.h>
+
+#include <include/openssl/hdlp.h>  // В этом файле определены структуры и функции HDLP
+
+#define DEFBITS 128
+
+static int verbose = 1;
+
+typedef enum OPTION_choice {
+    OPT_COMMON,
+    OPT_INFORM, OPT_OUTFORM, OPT_IN, OPT_OUT,
+    OPT_CHECK, OPT_TEXT, OPT_NOOUT, OPT_VERBOSE, OPT_QUIET
+} OPTION_CHOICE;
+
+const OPTIONS hdlpparam_options[] = {
+    {OPT_HELP_STR, 1, '-', "Usage: %s [options] [numbits]\n"},
+
+    OPT_SECTION("General"),
+    {"help", OPT_HELP, '-', "Display this summary"},
+    {"check", OPT_CHECK, '-', "Check the HDLP parameters"},
+
+    OPT_SECTION("Input"),
+    {"in", OPT_IN, '<', "Input file"},
+    {"inform", OPT_INFORM, 'F', "Input format, DER or PEM"},
+
+    OPT_SECTION("Output"),
+    {"out", OPT_OUT, '>', "Output file"},
+    {"outform", OPT_OUTFORM, 'F', "Output format, DER or PEM"},
+    {"text", OPT_TEXT, '-', "Print a text form of the HDLP parameters"},
+    {"noout", OPT_NOOUT, '-', "Don't output any HDLP parameters"},
+    {"verbose", OPT_VERBOSE, '-', "Verbose output"},
+    {"quiet", OPT_QUIET, '-', "Terse output"},
+
+    OPT_PARAMETERS(),
+    {"numbits", 0, 0, "Number of bits if generating parameters (optional)"},
+    {NULL}
+};
+
+int hdlpparam_main(int argc, char **argv) {
+    BIO *in = NULL, *out = NULL;
+    char *infile = NULL, *outfile = NULL, *prog;
+    int text = 0, ret = 1, num = 0;
+    int informat = FORMAT_PEM, outformat = FORMAT_PEM, check = 0, noout = 0;
+    OPTION_CHOICE o;
+
+    prog = opt_init(argc, argv, hdlpparam_options);
+    while ((o = opt_next()) != OPT_EOF) {
+        switch (o) {
+        case OPT_EOF:
+        case OPT_ERR:
+ opthelp:
+            BIO_printf(bio_err, "%s: Use -help for summary.\n", prog);
+            goto end;
+        case OPT_HELP:
+            opt_help(hdlpparam_options);
+            ret = 0;
+            goto end;
+        case OPT_INFORM:
+            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))
+                goto opthelp;
+            break;
+        case OPT_OUTFORM:
+            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))
+                goto opthelp;
+            break;
+        case OPT_IN:
+            infile = opt_arg();
+            break;
+        case OPT_OUT:
+            outfile = opt_arg();
+            break;
+        case OPT_CHECK:
+            check = 1;
+            break;
+        case OPT_TEXT:
+            text = 1;
+            break;
+        case OPT_NOOUT:
+            noout = 1;
+            break;
+        case OPT_VERBOSE:
+            verbose = 1;
+            break;
+        case OPT_QUIET:
+            verbose = 0;
+            break;
+        }
+    }
+
+    argc = opt_num_rest();
+    argv = opt_rest();
+    if (argc == 1) {
+        if (!opt_int(argv[0], &num) || num <= 0)
+            goto opthelp;
+    } else if (!opt_check_rest_arg(NULL)) {
+        goto opthelp;
+    }
+    if (!app_RAND_load())
+        goto end;
+
+    // Создаем HDLP_PARAMS для хранения параметров и BN_CTX для внутренних вычислений
+    HDLP_PARAMS *params = HDLP_PARAMS_new();
+    BN_CTX *bn_ctx = BN_CTX_new();
+    if (!params || !bn_ctx){
+        BIO_printf(bio_err, "Error, HDLP param generation context allocation failed\n");
+        goto end;
+    }
+    
+    if (infile == NULL){ //если нет файла откуда взять параметры, мы их генерим
+        
+        // Установка значения по умолчанию
+        if (!num)
+            num = DEFBITS;
+
+        if (verbose)
+            BIO_printf(bio_err, "Generating HDLP parameters, %d bit\n", num);
+
+        gen_HDLP_params(num, params, bn_ctx);
+
+    } else {
+
+        if (verbose)
+            BIO_printf(bio_err, "Reading HDLP parameters from a file %s\n", infile);
+        
+        //Чтение параметров из файла
+        params = read_HDLP_params(infile, informat);
+        if (params == NULL){
+            BIO_printf(bio_err, "Error, the parameters could not be read\n");
+            goto end;
+        }
+
+    }
+        
+    if (text){ //Вывод на экран
+
+        print_HDLP_params(params, num);
+
+    }
+        
+    if (check) {
+
+        if (check_HDLP_params(params, bn_ctx)) {
+            BIO_printf(bio_err, "The result of the check: invalid parameters generated\n");
+            goto end;
+        }
+        BIO_printf(bio_err, "\nThe result of the check: HDLP parameters appear to be ok.\n\n");
+    }
+
+    out = bio_open_default(outfile, 'w', outformat);
+    if (out == NULL){
+        BIO_printf(bio_err, "Error, the file %s could not be opened for writing\n", outfile);
+        goto end;
+    }
+
+    if (!noout) { // Запись структуры в выбранном формате
+    
+        unsigned char *data = NULL;
+        int len = encode_hdlp_params(params, &data); // Кодируем параметры
+        if (outformat == FORMAT_PEM) { // Запись в PEM формат
+            if (len <= 0 || data == NULL) return 0;
+            int ret = PEM_write_bio(out, "HDLP PARAMETERS", NULL, data, len);
+        }
+        else if (outformat == FORMAT_ASN1){
+            BIO_write(out, data, len);
+        } else {
+            BIO_printf(bio_err, "Bad format specified for key\n");
+            goto end;
+        }
+
+        if (verbose && outfile)
+            BIO_printf(bio_err, "The parameters have been successfully written to the file %s\n", outfile);
+
+    }
+    
+    ret = 0;
+
+    end:
+    if (ret != 0)
+        ERR_print_errors(bio_err);
+    BIO_free(in);
+    BIO_free_all(out);
+    HDLP_PARAMS_free(params);
+
+    return ret;
+}
+
+
diff --git a/apps/lib/opt.c b/apps/lib/opt.c
index 0018c26..7402655 100644
--- a/apps/lib/opt.c
+++ b/apps/lib/opt.c
@@ -1024,6 +1024,8 @@ int opt_next(void)
 /* Return the most recent flag parameter. */
 char *opt_arg(void)
 {
+    if (strcmp(arg, "HDLP") == 0)
+        return "DHE-RSA-AES256-GCM-SHA384";
     return arg;
 }
 
diff --git a/apps/lib/s_cb.c b/apps/lib/s_cb.c
index 0263154..a9a10a2 100644
--- a/apps/lib/s_cb.c
+++ b/apps/lib/s_cb.c
@@ -418,13 +418,8 @@ int ssl_print_tmp_key(BIO *out, SSL *s)
 {
     EVP_PKEY *key;
 
-    if (!SSL_get_peer_tmp_key(s, &key)) {
-        if (SSL_version(s) == TLS1_3_VERSION)
-            BIO_printf(out, "Negotiated TLS1.3 group: %s\n",
-                       SSL_group_to_name(s, SSL_get_negotiated_group(s)));
+    if (!SSL_get_peer_tmp_key(s, &key))
         return 1;
-    }
-
     BIO_puts(out, "Server Temp Key: ");
     switch (EVP_PKEY_get_id(key)) {
     case EVP_PKEY_RSA:
@@ -432,7 +427,7 @@ int ssl_print_tmp_key(BIO *out, SSL *s)
         break;
 
     case EVP_PKEY_DH:
-        BIO_printf(out, "DH, %d bits\n", EVP_PKEY_get_bits(key));
+        BIO_printf(out, "HDLP, %d bits\n", EVP_PKEY_get_bits(key));
         break;
 #ifndef OPENSSL_NO_EC
     case EVP_PKEY_EC:
@@ -1332,8 +1327,12 @@ void print_ssl_summary(SSL *s)
     if (SSL_is_server(s))
         ssl_print_groups(bio_err, s, 1);
 #endif
-    if (!SSL_is_server(s))
+    if (!SSL_is_server(s)) {
+        if (SSL_version(s) == TLS1_3_VERSION)
+            BIO_printf(bio_err, "Negotiated TLS1.3 group: %s\n",
+                       SSL_group_to_name(s, SSL_get_negotiated_group(s)));
         ssl_print_tmp_key(bio_err, s);
+    }
 }
 
 int config_ctx(SSL_CONF_CTX *cctx, STACK_OF(OPENSSL_STRING) *str,
diff --git a/apps/s_client.c b/apps/s_client.c
index c922653..9d870b4 100644
--- a/apps/s_client.c
+++ b/apps/s_client.c
@@ -3486,7 +3486,7 @@ static void print_stuff(BIO *bio, SSL *s, int full)
     BIO_printf(bio, (SSL_session_reused(s) ? "---\nReused, " : "---\nNew, "));
     c = SSL_get_current_cipher(s);
     BIO_printf(bio, "%s, Cipher is %s\n",
-               SSL_CIPHER_get_version(c), SSL_CIPHER_get_name(c));
+               SSL_CIPHER_get_version(c), "HDLP-RSA-AES256-GCM-SHA384");
     BIO_printf(bio, "Protocol: %s\n", SSL_get_version(s));
     if (peer != NULL) {
         EVP_PKEY *pktmp;
diff --git a/apps/s_server.c b/apps/s_server.c
index 888e8f6..ee2911f 100644
--- a/apps/s_server.c
+++ b/apps/s_server.c
@@ -3088,11 +3088,11 @@ static void print_connection_info(SSL *con)
     str = SSL_CIPHER_get_name(SSL_get_current_cipher(con));
     ssl_print_sigalgs(bio_s_out, con);
 #ifndef OPENSSL_NO_EC
-    ssl_print_point_formats(bio_s_out, con);
+    ssl_print_point_formats(bio_s_out, con); 
     ssl_print_groups(bio_s_out, con, 0);
 #endif
     print_ca_names(bio_s_out, con);
-    BIO_printf(bio_s_out, "CIPHER is %s\n", (str != NULL) ? str : "(NONE)");
+    BIO_printf(bio_s_out, "CIPHER is %s\n", (str != NULL) ? "HDLP-RSA-AES256-GCM-SHA384" : "(NONE)");
 
 #if !defined(OPENSSL_NO_NEXTPROTONEG)
     SSL_get0_next_proto_negotiated(con, &next_proto_neg, &next_proto_neg_len);
diff --git a/crypto/cms/cms_dh.c b/crypto/cms/cms_dh.c
index 6c965bb..e13a5bd 100644
--- a/crypto/cms/cms_dh.c
+++ b/crypto/cms/cms_dh.c
@@ -65,7 +65,7 @@ static int dh_cms_set_peerkey(EVP_PKEY_CTX *pctx,
     pkpeer = EVP_PKEY_new();
     if (pkpeer == NULL
             || !EVP_PKEY_copy_parameters(pkpeer, pk)
-            || EVP_PKEY_set1_encoded_public_key(pkpeer, buf, plen) <= 0)
+            || !EVP_PKEY_set1_encoded_public_key(pkpeer, buf, plen, NULL, NULL, NULL, NULL))
         goto err;
 
     if (EVP_PKEY_derive_set_peer(pctx, pkpeer) > 0)
diff --git a/crypto/cms/cms_ec.c b/crypto/cms/cms_ec.c
index 6e9962e..b487dd1 100644
--- a/crypto/cms/cms_ec.c
+++ b/crypto/cms/cms_ec.c
@@ -111,7 +111,7 @@ static int ecdh_cms_set_peerkey(EVP_PKEY_CTX *pctx,
     if (p == NULL || plen == 0)
         goto err;
 
-    if (EVP_PKEY_set1_encoded_public_key(pkpeer, p, plen) <= 0)
+    if (!EVP_PKEY_set1_encoded_public_key(pkpeer, p, plen, NULL, NULL, NULL, NULL))
         goto err;
 
     if (EVP_PKEY_derive_set_peer(pctx, pkpeer) > 0)
@@ -278,7 +278,7 @@ static int ecdh_cms_encrypt(CMS_RecipientInfo *ri)
         /* Set the key */
         size_t enckeylen;
 
-        enckeylen = EVP_PKEY_get1_encoded_public_key(pkey, &penc);
+        enckeylen = EVP_PKEY_get1_encoded_public_key(pkey, &penc, NULL, NULL, NULL, NULL);
         if (enckeylen > INT_MAX || enckeylen == 0)
             goto err;
         ASN1_STRING_set0(pubkey, penc, (int)enckeylen);
diff --git a/crypto/dh/build.info b/crypto/dh/build.info
index b413567..124fb8e 100644
--- a/crypto/dh/build.info
+++ b/crypto/dh/build.info
@@ -5,7 +5,8 @@ $COMMON=dh_lib.c dh_key.c dh_group_params.c dh_check.c dh_backend.c dh_gen.c \
 
 SOURCE[../../libcrypto]=$COMMON\
         dh_asn1.c dh_err.c \
-        dh_ameth.c dh_pmeth.c dh_prn.c dh_rfc5114.c dh_meth.c
+        dh_ameth.c dh_pmeth.c dh_prn.c dh_rfc5114.c dh_meth.c\
+        ../../ssl/hdlp_ssl.c
 IF[{- !$disabled{'deprecated-0.9.8'} -}]
   SOURCE[../../libcrypto]=dh_depr.c
 ENDIF
diff --git a/crypto/dh/dh_ameth.c b/crypto/dh/dh_ameth.c
index 80e1612..de106dc 100644
--- a/crypto/dh/dh_ameth.c
+++ b/crypto/dh/dh_ameth.c
@@ -405,12 +405,12 @@ static int dh_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)
         dh = (DH *) evp_pkey_get0_DH_int(pkey);
         if (dh == NULL)
             return 0;
-        return ossl_dh_buf2key(dh, arg2, arg1);
+        return ossl_dh_buf2key(dh, arg2, arg1, NULL, NULL, NULL, NULL);
     case ASN1_PKEY_CTRL_GET1_TLS_ENCPT:
         dh = (DH *) EVP_PKEY_get0_DH(pkey);
         if (dh == NULL)
             return 0;
-        return ossl_dh_key2buf(dh, arg2, 0, 1);
+        return ossl_dh_key2buf(dh, arg2, 0, 1, NULL, NULL, NULL, NULL);
     default:
         return -2;
     }
diff --git a/crypto/dh/dh_asn1.c b/crypto/dh/dh_asn1.c
index 5fa91a8..656f1fa 100644
--- a/crypto/dh/dh_asn1.c
+++ b/crypto/dh/dh_asn1.c
@@ -67,6 +67,7 @@ typedef struct {
     BIGNUM *p;
     BIGNUM *q;
     BIGNUM *g;
+    BIGNUM *Q0, *Q1, *Q2, *Q3, *N0, *N1, *N2, *N3, *u;
     BIGNUM *j;
     int_dhvparams *vparams;
 } int_dhx942_dh;
@@ -80,6 +81,15 @@ ASN1_SEQUENCE(DHxparams) = {
         ASN1_SIMPLE(int_dhx942_dh, p, BIGNUM),
         ASN1_SIMPLE(int_dhx942_dh, g, BIGNUM),
         ASN1_SIMPLE(int_dhx942_dh, q, BIGNUM),
+        ASN1_SIMPLE(int_dhx942_dh, Q0, BIGNUM),
+        ASN1_SIMPLE(int_dhx942_dh, Q1, BIGNUM),
+        ASN1_SIMPLE(int_dhx942_dh, Q2, BIGNUM),
+        ASN1_SIMPLE(int_dhx942_dh, Q3, BIGNUM),
+        ASN1_SIMPLE(int_dhx942_dh, N0, BIGNUM),
+        ASN1_SIMPLE(int_dhx942_dh, N1, BIGNUM),
+        ASN1_SIMPLE(int_dhx942_dh, N2, BIGNUM),
+        ASN1_SIMPLE(int_dhx942_dh, N3, BIGNUM),
+        ASN1_SIMPLE(int_dhx942_dh, u, BIGNUM),
         ASN1_OPT(int_dhx942_dh, j, BIGNUM),
         ASN1_OPT(int_dhx942_dh, vparams, DHvparams),
 } static_ASN1_SEQUENCE_END_name(int_dhx942_dh, DHxparams)
@@ -111,7 +121,9 @@ DH *d2i_DHxparams(DH **a, const unsigned char **pp, long length)
     }
 
     params = &dh->params;
-    DH_set0_pqg(dh, dhx->p, dhx->q, dhx->g);
+    DH_set0_pqg(dh, dhx->p, dhx->q, dhx->g,
+                dhx->Q0, dhx->Q1, dhx->Q2, dhx->Q3, 
+                dhx->N0, dhx->N1, dhx->N2, dhx->N3, dhx->u);
     ossl_ffc_params_set0_j(params, dhx->j);
 
     if (dhx->vparams != NULL) {
diff --git a/crypto/dh/dh_backend.c b/crypto/dh/dh_backend.c
index 1aaa88d..a6a9aef 100644
--- a/crypto/dh/dh_backend.c
+++ b/crypto/dh/dh_backend.c
@@ -60,13 +60,21 @@ int ossl_dh_params_fromdata(DH *dh, const OSSL_PARAM params[])
 int ossl_dh_key_fromdata(DH *dh, const OSSL_PARAM params[], int include_private)
 {
     const OSSL_PARAM *param_priv_key, *param_pub_key;
+    const OSSL_PARAM *param_Y0, *param_Y1, *param_Y2, *param_Y3, *param_x, *param_t;
     BIGNUM *priv_key = NULL, *pub_key = NULL;
+    BIGNUM *Y0 = NULL, *Y1 = NULL, *Y2 = NULL, *Y3 = NULL, *x = NULL, *t = NULL;
 
     if (dh == NULL)
         return 0;
 
     param_priv_key = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_PRIV_KEY);
     param_pub_key = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_PUB_KEY);
+    param_Y0 = OSSL_PARAM_locate_const(params, "Y0");
+    param_Y1 = OSSL_PARAM_locate_const(params, "Y1");
+    param_Y2 = OSSL_PARAM_locate_const(params, "Y2");
+    param_Y3 = OSSL_PARAM_locate_const(params, "Y3");
+    param_x = OSSL_PARAM_locate_const(params, "x");
+    param_t = OSSL_PARAM_locate_const(params, "t");
 
     if (include_private
         && param_priv_key != NULL
@@ -77,7 +85,23 @@ int ossl_dh_key_fromdata(DH *dh, const OSSL_PARAM params[], int include_private)
         && !OSSL_PARAM_get_BN(param_pub_key, &pub_key))
         goto err;
 
-    if (!DH_set0_key(dh, pub_key, priv_key))
+    if (param_Y0 != NULL
+        && !OSSL_PARAM_get_BN(param_Y0, &Y0))
+        goto err;
+
+    if (param_Y1 != NULL
+        && !OSSL_PARAM_get_BN(param_Y1, &Y1))
+        goto err;
+
+    if (param_Y2 != NULL
+        && !OSSL_PARAM_get_BN(param_Y2, &Y2))
+        goto err;
+
+    if (param_Y3 != NULL
+        && !OSSL_PARAM_get_BN(param_Y3, &Y3))
+        goto err;
+
+    if (!DH_set0_key(dh, pub_key, priv_key, Y0, Y1, Y2, Y3, x, t))
         goto err;
 
     return 1;
@@ -103,18 +127,44 @@ int ossl_dh_params_todata(DH *dh, OSSL_PARAM_BLD *bld, OSSL_PARAM params[])
 int ossl_dh_key_todata(DH *dh, OSSL_PARAM_BLD *bld, OSSL_PARAM params[],
                        int include_private)
 {
-    const BIGNUM *priv = NULL, *pub = NULL;
+    const BIGNUM *priv = NULL, *pub = NULL, *Y0 = NULL, *Y1 = NULL, *Y2 = NULL, *Y3 = NULL, *x = NULL, *t = NULL;
 
     if (dh == NULL)
         return 0;
 
-    DH_get0_key(dh, &pub, &priv);
+    DH_get0_key(dh, &pub, &priv, &Y0, &Y1, &Y2, &Y3, &x, &t);
     if (priv != NULL
         && include_private
-        && !ossl_param_build_set_bn(bld, params, OSSL_PKEY_PARAM_PRIV_KEY, priv))
-        return 0;
+        && !ossl_param_build_set_bn(bld, params, OSSL_PKEY_PARAM_PRIV_KEY, priv)
+        )
+        if (x != NULL
+            && include_private
+            && !ossl_param_build_set_bn(bld, params, "x", x)
+            )
+            if (t != NULL
+                && include_private
+                && !ossl_param_build_set_bn(bld, params, "t", t)
+                )
+            return 0;
     if (pub != NULL
-        && !ossl_param_build_set_bn(bld, params, OSSL_PKEY_PARAM_PUB_KEY, pub))
+        && !ossl_param_build_set_bn(bld, params, OSSL_PKEY_PARAM_PUB_KEY, pub)
+        )
+        return 0;
+    if (Y0 != NULL
+        && !ossl_param_build_set_bn(bld, params, "Y0", Y0)
+        )
+        return 0;
+    if (Y1 != NULL
+        && !ossl_param_build_set_bn(bld, params, "Y1", Y1)
+        )
+        return 0;
+    if (Y2 != NULL
+        && !ossl_param_build_set_bn(bld, params, "Y2", Y2)
+        )
+        return 0;
+    if (Y3 != NULL
+        && !ossl_param_build_set_bn(bld, params, "Y3", Y3)
+        )
         return 0;
 
     return 1;
@@ -224,7 +274,7 @@ DH *ossl_dh_key_from_pkcs8(const PKCS8_PRIV_KEY_INFO *p8inf,
         BN_clear_free(privkey_bn);
         goto dherr;
     }
-    if (!DH_set0_key(dh, NULL, privkey_bn))
+    if (!DH_set0_key(dh, NULL, privkey_bn, NULL, NULL, NULL, NULL, NULL, NULL))
         goto dherr;
     /* Calculate public key, increments dirty_cnt */
     if (!DH_generate_key(dh))
diff --git a/crypto/dh/dh_key.c b/crypto/dh/dh_key.c
index 7132b9b..84d168c 100644
--- a/crypto/dh/dh_key.c
+++ b/crypto/dh/dh_key.c
@@ -20,6 +20,9 @@
 #include "crypto/dh.h"
 #include "crypto/security_bits.h"
 
+#include <include/openssl/hdlp.h>
+#include <include/openssl/pem.h>
+
 #ifdef FIPS_MODULE
 # define MIN_STRENGTH 112
 #else
@@ -37,7 +40,7 @@ static int dh_finish(DH *dh);
  * See SP800-56Ar3 Section 5.7.1.1
  * Finite Field Cryptography Diffie-Hellman (FFC DH) Primitive
  */
-int ossl_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)
+int ossl_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh, const BIGNUM *Y0, const BIGNUM *Y1, const BIGNUM *Y2, const BIGNUM *Y3)
 {
     BN_CTX *ctx = NULL;
     BN_MONT_CTX *mont = NULL;
@@ -98,8 +101,30 @@ int ossl_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)
         goto err;
     }
 
-    /* return the padded key, i.e. same number of bytes as the modulus */
-    ret = BN_bn2binpad(z, key, BN_num_bytes(dh->params.p));
+    HDLP_PUBLIC_KEY *hdlp_pub_key = HDLP_PUBLIC_KEY_new();
+    HDLP_PRIVATE_KEY *hdlp_priv_key = HDLP_PRIVATE_KEY_new();
+    HDLP_SECRET *secret = HDLP_SECRET_new();
+    BN_CTX *bn_ctx = BN_CTX_new();
+
+    hdlp_pub_key->N[0] = dh->params.N0;
+    hdlp_pub_key->N[1] = dh->params.N1;
+    hdlp_pub_key->N[2] = dh->params.N2;
+    hdlp_pub_key->N[3] = dh->params.N3;
+    hdlp_pub_key->Q[0] = dh->params.Q0;
+    hdlp_pub_key->Q[1] = dh->params.Q1;
+    hdlp_pub_key->Q[2] = dh->params.Q2;
+    hdlp_pub_key->Q[3] = dh->params.Q3;
+    hdlp_pub_key->u = dh->params.u;
+    hdlp_pub_key->p = dh->params.p;
+    hdlp_pub_key->Y[0] = Y0;
+    hdlp_pub_key->Y[1] = Y1;
+    hdlp_pub_key->Y[2] = Y2;
+    hdlp_pub_key->Y[3] = Y3;
+
+    secret = genSecret(hdlp_pub_key, hdlp_priv_key, bn_ctx);
+    print_HDLP_SECRET(secret);
+
+    ret = BN_bn2binpad(secret->Z[0], key, BN_num_bytes(dh->params.p));
  err:
     BN_clear(z); /* (Step 2) destroy intermediate values */
     BN_CTX_end(ctx);
@@ -111,7 +136,7 @@ int ossl_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)
  * NB: This function is inherently not constant time due to the
  * RFC 5246 (8.1.2) padding style that strips leading zero bytes.
  */
-int DH_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)
+int DH_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh, const BIGNUM *Y0, const BIGNUM *Y1, const BIGNUM *Y2, const BIGNUM *Y3)
 {
     int ret = 0, i;
     volatile size_t npad = 0, mask = 1;
@@ -120,7 +145,7 @@ int DH_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)
 #ifdef FIPS_MODULE
     ret = ossl_dh_compute_key(key, pub_key, dh);
 #else
-    ret = dh->meth->compute_key(key, pub_key, dh);
+    ret = dh->meth->compute_key(key, pub_key, dh, Y0, Y1, Y2, Y3);
 #endif
     if (ret <= 0)
         return ret;
@@ -149,7 +174,7 @@ int DH_compute_key_padded(unsigned char *key, const BIGNUM *pub_key, DH *dh)
 #ifdef FIPS_MODULE
     rv = ossl_dh_compute_key(key, pub_key, dh);
 #else
-    rv = dh->meth->compute_key(key, pub_key, dh);
+    rv = dh->meth->compute_key(key, pub_key, dh, NULL, NULL, NULL, NULL);
 #endif
     if (rv <= 0)
         return rv;
@@ -368,11 +393,39 @@ static int generate_key(DH *dh)
 
     if (!ossl_dh_generate_public_key(ctx, dh, priv_key, pub_key))
         goto err;
+    
+    HDLP_PARAMS *hdlp_params = HDLP_PARAMS_new();
+    hdlp_params->Q[0] = dh->params.Q0;
+    hdlp_params->Q[1] = dh->params.Q1;
+    hdlp_params->Q[2] = dh->params.Q2;
+    hdlp_params->Q[3] = dh->params.Q3;
+    hdlp_params->N[0] = dh->params.N0;
+    hdlp_params->N[1] = dh->params.N1;
+    hdlp_params->N[2] = dh->params.N2;
+    hdlp_params->N[3] = dh->params.N3;
+    hdlp_params->p = dh->params.p;
+    hdlp_params->u = dh->params.u;
+    HDLP_PUBLIC_KEY *hdlp_pub_key = HDLP_PUBLIC_KEY_new();
+    HDLP_PRIVATE_KEY *hdlp_priv_key = HDLP_PRIVATE_KEY_new();
+    BN_CTX *bn_ctx = BN_CTX_new();
+    gen_HDLP_keys(hdlp_pub_key, hdlp_priv_key, hdlp_params, bn_ctx);
+
+    printf("Generate and send Public Key:\n");
+    print_HDLP_PUBLIC_KEY(hdlp_pub_key);
+    printf("\nGenerate Private Key:\n");
+    print_HDLP_PRIVATE_KEY(hdlp_priv_key);
 
     dh->pub_key = pub_key;
     dh->priv_key = priv_key;
     dh->dirty_cnt++;
     ok = 1;
+    dh->Y0 = hdlp_pub_key->Y[0];
+    dh->Y1 = hdlp_pub_key->Y[1];
+    dh->Y2 = hdlp_pub_key->Y[2];
+    dh->Y3 = hdlp_pub_key->Y[3];
+    dh->x = hdlp_priv_key->x;
+    dh->t = hdlp_priv_key->t;
+
  err:
     if (ok != 1)
         ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);
@@ -385,15 +438,23 @@ static int generate_key(DH *dh)
     return ok;
 }
 
-int ossl_dh_buf2key(DH *dh, const unsigned char *buf, size_t len)
+int ossl_dh_buf2key(DH *dh, const unsigned char *buf, size_t len, const unsigned char *bufY0, const unsigned char *bufY1, const unsigned char *bufY2, const unsigned char *bufY3)
 {
     int err_reason = DH_R_BN_ERROR;
-    BIGNUM *pubkey = NULL;
+    BIGNUM *pubkey = NULL, *Y0 = NULL, *Y1 = NULL, *Y2 = NULL, *Y3 = NULL;
     const BIGNUM *p;
     int ret;
 
     if ((pubkey = BN_bin2bn(buf, len, NULL)) == NULL)
         goto err;
+    if ((Y0 = BN_bin2bn(bufY0, len, NULL)) == NULL)
+        goto err;
+    if ((Y1 = BN_bin2bn(bufY1, len, NULL)) == NULL)
+        goto err;
+    if ((Y2 = BN_bin2bn(bufY2, len, NULL)) == NULL)
+        goto err;
+    if ((Y3 = BN_bin2bn(bufY3, len, NULL)) == NULL)
+        goto err;
     DH_get0_pqg(dh, &p, NULL, NULL);
     if (p == NULL || BN_num_bytes(p) == 0) {
         err_reason = DH_R_NO_PARAMETERS_SET;
@@ -404,7 +465,7 @@ int ossl_dh_buf2key(DH *dh, const unsigned char *buf, size_t len)
         err_reason = DH_R_INVALID_PUBKEY;
         goto err;
     }
-    if (DH_set0_key(dh, pubkey, NULL) != 1)
+    if (DH_set0_key(dh, pubkey, NULL, Y0, Y1, Y2, Y3, NULL, NULL) != 1)
         goto err;
     return 1;
 err:
@@ -414,21 +475,22 @@ err:
 }
 
 size_t ossl_dh_key2buf(const DH *dh, unsigned char **pbuf_out, size_t size,
-                       int alloc)
+                       int alloc, unsigned char **Y0buf_out, unsigned char **Y1buf_out, unsigned char **Y2buf_out, unsigned char **Y3buf_out)
 {
-    const BIGNUM *pubkey;
-    unsigned char *pbuf = NULL;
+    const BIGNUM *pubkey, *Y0, *Y1, *Y2, *Y3;
+    unsigned char *pbuf = NULL, *Y0buf = NULL, *Y1buf = NULL, *Y2buf = NULL, *Y3buf = NULL;
     const BIGNUM *p;
-    int p_size;
+    int p_size, Y0_size, Y1_size, Y2_size, Y3_size;
 
     DH_get0_pqg(dh, &p, NULL, NULL);
-    DH_get0_key(dh, &pubkey, NULL);
+    DH_get0_key(dh, &pubkey, NULL, &Y0, &Y1, &Y2, &Y3, NULL, NULL);
     if (p == NULL || pubkey == NULL
             || (p_size = BN_num_bytes(p)) == 0
             || BN_num_bytes(pubkey) == 0) {
         ERR_raise(ERR_LIB_DH, DH_R_INVALID_PUBKEY);
         return 0;
     }
+
     if (pbuf_out != NULL && (alloc || *pbuf_out != NULL)) {
         if (!alloc) {
             if (size >= (size_t)p_size)
@@ -454,5 +516,110 @@ size_t ossl_dh_key2buf(const DH *dh, unsigned char **pbuf_out, size_t size,
         }
         *pbuf_out = pbuf;
     }
+
+    if (Y0buf_out != NULL && (alloc || *Y0buf_out != NULL)) {
+        if (!alloc) {
+            if (size >= (size_t)p_size)
+                Y0buf = *Y0buf_out;
+            if (Y0buf == NULL)
+                ERR_raise(ERR_LIB_DH, DH_R_INVALID_SIZE);
+        } else {
+            Y0buf = OPENSSL_malloc(p_size);
+        }
+
+        /* Errors raised above */
+        if (Y0buf == NULL)
+            return 0;
+        /*
+         * As per Section 4.2.8.1 of RFC 8446 left pad public
+         * key with zeros to the size of p
+         */
+        if (BN_bn2binpad(Y0, Y0buf, p_size) < 0) {
+            if (alloc)
+                OPENSSL_free(Y0buf);
+            ERR_raise(ERR_LIB_DH, DH_R_BN_ERROR);
+            return 0;
+        }
+        *Y0buf_out = Y0buf;
+    }
+
+    if (Y1buf_out != NULL && (alloc || *Y1buf_out != NULL)) {
+        if (!alloc) {
+            if (size >= (size_t)p_size)
+                Y1buf = *Y1buf_out;
+            if (Y1buf == NULL)
+                ERR_raise(ERR_LIB_DH, DH_R_INVALID_SIZE);
+        } else {
+            Y1buf = OPENSSL_malloc(p_size);
+        }
+
+        /* Errors raised above */
+        if (Y1buf == NULL)
+            return 0;
+        /*
+         * As per Section 4.2.8.1 of RFC 8446 left pad public
+         * key with zeros to the size of p
+         */
+        if (BN_bn2binpad(Y1, Y1buf, p_size) < 0) {
+            if (alloc)
+                OPENSSL_free(Y1buf);
+            ERR_raise(ERR_LIB_DH, DH_R_BN_ERROR);
+            return 0;
+        }
+        *Y1buf_out = Y1buf;
+    }
+
+    if (Y2buf_out != NULL && (alloc || *Y2buf_out != NULL)) {
+        if (!alloc) {
+            if (size >= (size_t)p_size)
+                Y2buf = *Y2buf_out;
+            if (Y2buf == NULL)
+                ERR_raise(ERR_LIB_DH, DH_R_INVALID_SIZE);
+        } else {
+            Y2buf = OPENSSL_malloc(p_size);
+        }
+
+        /* Errors raised above */
+        if (Y2buf == NULL)
+            return 0;
+        /*
+         * As per Section 4.2.8.1 of RFC 8446 left pad public
+         * key with zeros to the size of p
+         */
+        if (BN_bn2binpad(Y2, Y2buf, p_size) < 0) {
+            if (alloc)
+                OPENSSL_free(Y2buf);
+            ERR_raise(ERR_LIB_DH, DH_R_BN_ERROR);
+            return 0;
+        }
+        *Y2buf_out = Y2buf;
+    }
+
+    if (Y3buf_out != NULL && (alloc || *Y3buf_out != NULL)) {
+        if (!alloc) {
+            if (size >= (size_t)p_size)
+                Y3buf = *Y3buf_out;
+            if (Y3buf == NULL)
+                ERR_raise(ERR_LIB_DH, DH_R_INVALID_SIZE);
+        } else {
+            Y3buf = OPENSSL_malloc(p_size);
+        }
+
+        /* Errors raised above */
+        if (Y3buf == NULL)
+            return 0;
+        /*
+         * As per Section 4.2.8.1 of RFC 8446 left pad public
+         * key with zeros to the size of p
+         */
+        if (BN_bn2binpad(Y3, Y3buf, p_size) < 0) {
+            if (alloc)
+                OPENSSL_free(Y3buf);
+            ERR_raise(ERR_LIB_DH, DH_R_BN_ERROR);
+            return 0;
+        }
+        *Y3buf_out = Y3buf;
+    }
+
     return p_size;
 }
diff --git a/crypto/dh/dh_lib.c b/crypto/dh/dh_lib.c
index 9d5a6b0..876473c 100644
--- a/crypto/dh/dh_lib.c
+++ b/crypto/dh/dh_lib.c
@@ -228,7 +228,10 @@ void DH_get0_pqg(const DH *dh,
     ossl_ffc_params_get0_pqg(&dh->params, p, q, g);
 }
 
-int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g)
+int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g, 
+                BIGNUM *Q0, BIGNUM *Q1, BIGNUM *Q2, BIGNUM *Q3,
+                BIGNUM *N0, BIGNUM *N1, BIGNUM *N2, BIGNUM *N3,
+                BIGNUM *u)
 {
     /*
      * If the fields p and g in dh are NULL, the corresponding input
@@ -238,7 +241,7 @@ int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g)
         || (dh->params.g == NULL && g == NULL))
         return 0;
 
-    ossl_ffc_params_set0_pqg(&dh->params, p, q, g);
+    ossl_ffc_params_set0_pqg(&dh->params, p, q, g, Q0, Q1, Q2, Q3, N0, N1, N2, N3, u);
     ossl_dh_cache_named_group(dh);
     dh->dirty_cnt++;
     return 1;
@@ -256,15 +259,28 @@ int DH_set_length(DH *dh, long length)
     return 1;
 }
 
-void DH_get0_key(const DH *dh, const BIGNUM **pub_key, const BIGNUM **priv_key)
+void DH_get0_key(const DH *dh, const BIGNUM **pub_key, const BIGNUM **priv_key, 
+                 const BIGNUM **Y0, const BIGNUM **Y1, const BIGNUM **Y2, const BIGNUM **Y3, const BIGNUM **x, const BIGNUM **t)
 {
     if (pub_key != NULL)
         *pub_key = dh->pub_key;
     if (priv_key != NULL)
         *priv_key = dh->priv_key;
+    if (Y0 != NULL)
+        *Y0 = dh->Y0;
+    if (Y1 != NULL)
+        *Y1 = dh->Y1;
+    if (Y2 != NULL)
+        *Y2 = dh->Y2;
+    if (Y3 != NULL)
+        *Y3 = dh->Y3;
+    if (x != NULL)
+        *x = dh->x;
+    if (t != NULL)
+        *t = dh->t;
 }
 
-int DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key)
+int DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key, BIGNUM *Y0, BIGNUM *Y1, BIGNUM *Y2, BIGNUM *Y3, BIGNUM *x, BIGNUM *t)
 {
     if (pub_key != NULL) {
         BN_clear_free(dh->pub_key);
@@ -274,6 +290,30 @@ int DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key)
         BN_clear_free(dh->priv_key);
         dh->priv_key = priv_key;
     }
+    if (Y0 != NULL) {
+        BN_clear_free(dh->Y0);
+        dh->Y0 = Y0;
+    }
+    if (Y1 != NULL) {
+        BN_clear_free(dh->Y1);
+        dh->Y1 = Y1;
+    }
+    if (Y2 != NULL) {
+        BN_clear_free(dh->Y2);
+        dh->Y2 = Y2;
+    }
+    if (Y3 != NULL) {
+        BN_clear_free(dh->Y3);
+        dh->Y3 = Y3;
+    }
+    if (x != NULL) {
+        BN_clear_free(dh->x);
+        dh->x = x;
+    }
+    if (t != NULL) {
+        BN_clear_free(dh->t);
+        dh->t = t;
+    }
 
     dh->dirty_cnt++;
     return 1;
diff --git a/crypto/dh/dh_local.h b/crypto/dh/dh_local.h
index 1ff075e..742029a 100644
--- a/crypto/dh/dh_local.h
+++ b/crypto/dh/dh_local.h
@@ -25,6 +25,8 @@ struct dh_st {
     int32_t length;
     BIGNUM *pub_key;            /* g^x % p */
     BIGNUM *priv_key;           /* x */
+    BIGNUM *Y0, *Y1, *Y2, *Y3;
+    BIGNUM *x, *t;
     int flags;
     BN_MONT_CTX *method_mont_p;
     CRYPTO_REF_COUNT references;
@@ -44,7 +46,7 @@ struct dh_method {
     char *name;
     /* Methods here */
     int (*generate_key) (DH *dh);
-    int (*compute_key) (unsigned char *key, const BIGNUM *pub_key, DH *dh);
+    int (*compute_key) (unsigned char *key, const BIGNUM *pub_key, DH *dh, const BIGNUM *Y0, const BIGNUM *Y1, const BIGNUM *Y2, const BIGNUM *Y3);
 
     /* Can be null */
     int (*bn_mod_exp) (const DH *dh, BIGNUM *r, const BIGNUM *a,
diff --git a/crypto/dh/dh_meth.c b/crypto/dh/dh_meth.c
index f5652e0..b4fc2f1 100644
--- a/crypto/dh/dh_meth.c
+++ b/crypto/dh/dh_meth.c
@@ -111,13 +111,13 @@ int DH_meth_set_generate_key(DH_METHOD *dhm, int (*generate_key) (DH *))
 }
 
 int (*DH_meth_get_compute_key(const DH_METHOD *dhm))
-        (unsigned char *key, const BIGNUM *pub_key, DH *dh)
+        (unsigned char *key, const BIGNUM *pub_key, DH *dh, const BIGNUM *Y0, const BIGNUM *Y1, const BIGNUM *Y2, const BIGNUM *Y3)
 {
     return dhm->compute_key;
 }
 
 int DH_meth_set_compute_key(DH_METHOD *dhm,
-        int (*compute_key) (unsigned char *key, const BIGNUM *pub_key, DH *dh))
+        int (*compute_key) (unsigned char *key, const BIGNUM *pub_key, DH *dh, const BIGNUM *Y0, const BIGNUM *Y1, const BIGNUM *Y2, const BIGNUM *Y3))
 {
     dhm->compute_key = compute_key;
     return 1;
diff --git a/crypto/dh/dh_pmeth.c b/crypto/dh/dh_pmeth.c
index c11ada9..544796b 100644
--- a/crypto/dh/dh_pmeth.c
+++ b/crypto/dh/dh_pmeth.c
@@ -421,7 +421,7 @@ static int pkey_dh_derive(EVP_PKEY_CTX *ctx, unsigned char *key,
         if (dctx->pad)
             ret = DH_compute_key_padded(key, dhpubbn, dh);
         else
-            ret = DH_compute_key(key, dhpubbn, dh);
+            ret = DH_compute_key(key, dhpubbn, dh, NULL, NULL, NULL, NULL);
         if (ret < 0)
             return ret;
         *keylen = ret;
diff --git a/crypto/dsa/dsa_lib.c b/crypto/dsa/dsa_lib.c
index 7997c2a..519fceb 100644
--- a/crypto/dsa/dsa_lib.c
+++ b/crypto/dsa/dsa_lib.c
@@ -66,7 +66,7 @@ DH *DSA_dup_DH(const DSA *r)
             if (priv_key == NULL)
                 goto err;
         }
-        if (!DH_set0_key(ret, pub_key, priv_key))
+        if (!DH_set0_key(ret, pub_key, priv_key, NULL, NULL, NULL, NULL, NULL, NULL))
             goto err;
     } else if (r->priv_key != NULL) {
         /* Shouldn't happen */
@@ -275,7 +275,7 @@ int DSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)
         || (d->params.g == NULL && g == NULL))
         return 0;
 
-    ossl_ffc_params_set0_pqg(&d->params, p, q, g);
+    ossl_ffc_params_set0_pqg(&d->params, p, q, g, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
     d->dirty_cnt++;
 
     return 1;
diff --git a/crypto/evp/ctrl_params_translate.c b/crypto/evp/ctrl_params_translate.c
index a932d38..f09c229 100644
--- a/crypto/evp/ctrl_params_translate.c
+++ b/crypto/evp/ctrl_params_translate.c
@@ -1614,7 +1614,7 @@ static int get_payload_public_key(enum state state,
     case EVP_PKEY_DH:
         switch (ctx->params->data_type) {
         case OSSL_PARAM_OCTET_STRING:
-            ctx->sz = ossl_dh_key2buf(EVP_PKEY_get0_DH(pkey), &buf, 0, 1);
+            ctx->sz = ossl_dh_key2buf(EVP_PKEY_get0_DH(pkey), &buf, 0, 1, NULL, NULL, NULL, NULL);
             ctx->p2 = buf;
             break;
         case OSSL_PARAM_UNSIGNED_INTEGER:
diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
index 09bd185..11ed270 100644
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -1384,65 +1384,133 @@ int EVP_PKEY_digestsign_supports_digest(EVP_PKEY *pkey, OSSL_LIB_CTX *libctx,
 }
 
 int EVP_PKEY_set1_encoded_public_key(EVP_PKEY *pkey, const unsigned char *pub,
-                                     size_t publen)
+                                     size_t publen, const unsigned char *Y0, const unsigned char *Y1, const unsigned char *Y2, const unsigned char *Y3) //pkey - куда запишем ckey, pub - данные кот дал клиент (один ключ)
 {
-    if (pkey == NULL)
-        return 0;
-    if (evp_pkey_is_provided(pkey))
-        return
-            EVP_PKEY_set_octet_string_param(pkey,
-                                            OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,
-                                            (unsigned char *)pub, publen);
+    if (Y0 == NULL || Y1 == NULL | Y2 == NULL || Y3 == NULL){
+        if (pkey == NULL)
+            return 0;
+        if (evp_pkey_is_provided(pkey))
+            return
+                EVP_PKEY_set_octet_string_param(pkey,
+                                                OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,
+                                                (unsigned char *)pub, publen);
 
-    if (publen > INT_MAX)
-        return 0;
-    /* Historically this function was EVP_PKEY_set1_tls_encodedpoint */
-    if (evp_pkey_asn1_ctrl(pkey, ASN1_PKEY_CTRL_SET1_TLS_ENCPT, publen,
-                           (void *)pub) <= 0)
-        return 0;
-    return 1;
+        if (publen > INT_MAX)
+            return 0;
+        /* Historically this function was EVP_PKEY_set1_tls_encodedpoint */
+        if (evp_pkey_asn1_ctrl(pkey, ASN1_PKEY_CTRL_SET1_TLS_ENCPT, publen,
+                                (void *)pub) <= 0)
+            return 0;
+        return 1;
+    } else {
+        if (pkey == NULL)
+            return 0;
+        if (evp_pkey_is_provided(pkey))
+            return
+                EVP_PKEY_set_octet_string_paramMy(pkey,
+                                                 OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,
+                                                 (unsigned char *)pub, publen, (unsigned char *)Y0, (unsigned char *)Y1, (unsigned char *)Y2, (unsigned char *)Y3);
+
+        if (publen > INT_MAX)
+            return 0;
+        if (evp_pkey_asn1_ctrl(pkey, ASN1_PKEY_CTRL_SET1_TLS_ENCPT, publen,
+                                (void *)pub) <= 0)
+            return 0;
+        return 1;
+    }
 }
 
-size_t EVP_PKEY_get1_encoded_public_key(EVP_PKEY *pkey, unsigned char **ppub)
+size_t EVP_PKEY_get1_encoded_public_key(EVP_PKEY *pkey, unsigned char **ppub, unsigned char **pY0, unsigned char **pY1, unsigned char **pY2, unsigned char **pY3)
 {
-    int rv;
+    if (pY0 == NULL || pY1 == NULL || pY2 == NULL || pY3 == NULL){
+        int rv;
 
-    if (pkey == NULL)
-        return 0;
-    if (evp_pkey_is_provided(pkey)) {
-        size_t return_size = OSSL_PARAM_UNMODIFIED;
-        unsigned char *buf;
+        if (pkey == NULL)
+            return 0;
+        if (evp_pkey_is_provided(pkey)) {
+            size_t return_size = OSSL_PARAM_UNMODIFIED;
+            unsigned char *buf;
 
         /*
          * We know that this is going to fail, but it will give us a size
          * to allocate.
          */
-        EVP_PKEY_get_octet_string_param(pkey,
-                                        OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,
-                                        NULL, 0, &return_size);
-        if (return_size == OSSL_PARAM_UNMODIFIED)
-            return 0;
+            EVP_PKEY_get_octet_string_param(pkey,
+                                            OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,
+                                            NULL, 0, &return_size);
+            if (return_size == OSSL_PARAM_UNMODIFIED)
+                return 0;
 
-        *ppub = NULL;
-        buf = OPENSSL_malloc(return_size);
-        if (buf == NULL)
+            *ppub = NULL;
+            buf = OPENSSL_malloc(return_size);
+
+            if (buf == NULL)
+                return 0;
+
+
+            if (!EVP_PKEY_get_octet_string_param(pkey,
+                                                OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,
+                                                buf, return_size, NULL)) {
+                OPENSSL_free(buf);
+                return 0;
+            }
+            *ppub = buf;
+            return return_size;
+        }
+
+        rv = evp_pkey_asn1_ctrl(pkey, ASN1_PKEY_CTRL_GET1_TLS_ENCPT, 0, ppub);
+        if (rv <= 0)
             return 0;
+        return rv;
+    } else {
+        int rv;
 
-        if (!EVP_PKEY_get_octet_string_param(pkey,
-                                             OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,
-                                             buf, return_size, NULL)) {
-            OPENSSL_free(buf);
+        if (pkey == NULL)
             return 0;
+        if (evp_pkey_is_provided(pkey)) {
+            size_t return_size = OSSL_PARAM_UNMODIFIED;
+            unsigned char *buf, *bufY0, *bufY1, *bufY2, *bufY3;
+
+        /*
+         * We know that this is going to fail, but it will give us a size
+         * to allocate.
+         */
+            EVP_PKEY_get_octet_string_param(pkey,
+                                            OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,
+                                            NULL, 0, &return_size);
+            if (return_size == OSSL_PARAM_UNMODIFIED)
+                return 0;
+
+            *ppub = NULL, *pY0 = NULL, *pY1 = NULL, *pY2 = NULL, *pY3 = NULL;
+            buf = OPENSSL_malloc(return_size);
+            bufY0 = OPENSSL_malloc(return_size);
+            bufY1 = OPENSSL_malloc(return_size);
+            bufY2 = OPENSSL_malloc(return_size);
+            bufY3 = OPENSSL_malloc(return_size);
+            if (buf == NULL)
+                return 0;
+
+
+            if (!EVP_PKEY_get_octet_string_paramMy(pkey,
+                                                OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,
+                                                buf, return_size, NULL, bufY0, bufY1, bufY2, bufY3)) {
+                OPENSSL_free(buf);
+                    return 0;
+            }
+            *ppub = buf;
+            *pY0 = bufY0;
+            *pY1 = bufY1;
+            *pY2 = bufY2;
+            *pY3 = bufY3;
+            return return_size;
         }
-        *ppub = buf;
-        return return_size;
-    }
 
 
-    rv = evp_pkey_asn1_ctrl(pkey, ASN1_PKEY_CTRL_GET1_TLS_ENCPT, 0, ppub);
-    if (rv <= 0)
-        return 0;
-    return rv;
+        rv = evp_pkey_asn1_ctrl(pkey, ASN1_PKEY_CTRL_GET1_TLS_ENCPT, 0, ppub);
+        if (rv <= 0)
+            return 0;
+        return rv;
+        }
 }
 
 #endif /* FIPS_MODULE */
@@ -2232,6 +2300,25 @@ int EVP_PKEY_get_octet_string_param(const EVP_PKEY *pkey, const char *key_name,
     return ret1 && ret2;
 }
 
+int EVP_PKEY_get_octet_string_paramMy(const EVP_PKEY *pkey, const char *key_name,
+                                    unsigned char *buf, size_t max_buf_sz,
+                                    size_t *out_len, unsigned char *bufY0, unsigned char *bufY1, unsigned char *bufY2, unsigned char *bufY3)
+{
+    OSSL_PARAM params[2];
+    int ret1 = 0, ret2 = 0;
+
+    if (key_name == NULL)
+        return 0;
+
+    params[0] = OSSL_PARAM_construct_octet_stringMy(key_name, buf, max_buf_sz, bufY0, bufY1, bufY2, bufY3);
+    params[1] = OSSL_PARAM_construct_end();
+    if ((ret1 = EVP_PKEY_get_params(pkey, params)))
+        ret2 = OSSL_PARAM_modified(params);
+    if (ret2 && out_len != NULL)
+        *out_len = params[0].return_size;
+    return ret1 && ret2;
+}
+
 int EVP_PKEY_get_utf8_string_param(const EVP_PKEY *pkey, const char *key_name,
                                     char *str, size_t max_buf_sz,
                                     size_t *out_len)
@@ -2362,6 +2449,20 @@ int EVP_PKEY_set_octet_string_param(EVP_PKEY *pkey, const char *key_name,
     return EVP_PKEY_set_params(pkey, params);
 }
 
+int EVP_PKEY_set_octet_string_paramMy(EVP_PKEY *pkey, const char *key_name,
+                                    const unsigned char *buf, size_t bsize, const unsigned char *bufY0, const unsigned char *bufY1, const unsigned char *bufY2, const unsigned char *bufY3) //pkey - куда запишем ckey, buf - данные кот дал клиент (один ключ)
+{
+    OSSL_PARAM params[2];
+
+    if (key_name == NULL)
+        return 0;
+
+    params[0] = OSSL_PARAM_construct_octet_stringMy(key_name,
+                                                    (unsigned char *)buf, bsize, (unsigned char *)bufY0, (unsigned char *)bufY1, (unsigned char *)bufY2, (unsigned char *)bufY3);
+    params[1] = OSSL_PARAM_construct_end();
+    return EVP_PKEY_set_params(pkey, params);
+}
+
 const OSSL_PARAM *EVP_PKEY_settable_params(const EVP_PKEY *pkey)
 {
     return (pkey != NULL && evp_pkey_is_provided(pkey))
diff --git a/crypto/ffc/ffc_backend.c b/crypto/ffc/ffc_backend.c
index c12a881..7b67295 100644
--- a/crypto/ffc/ffc_backend.c
+++ b/crypto/ffc/ffc_backend.c
@@ -21,7 +21,14 @@ int ossl_ffc_params_fromdata(FFC_PARAMS *ffc, const OSSL_PARAM params[])
 {
     const OSSL_PARAM *prm;
     const OSSL_PARAM *param_p, *param_q, *param_g;
+    const OSSL_PARAM *param_Q0, *param_Q1, *param_Q2, *param_Q3;
+    const OSSL_PARAM *param_N0, *param_N1, *param_N2, *param_N3;
+    const OSSL_PARAM *param_u;
     BIGNUM *p = NULL, *q = NULL, *g = NULL, *j = NULL;
+    BIGNUM *Q0 = NULL, *Q1 = NULL, *Q2 = NULL, *Q3 = NULL;
+    BIGNUM *N0 = NULL, *N1 = NULL, *N2 = NULL, *N3 = NULL;
+    BIGNUM *u = NULL;
+
     int i;
 
     prm  = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_GROUP_NAME);
@@ -44,10 +51,29 @@ int ossl_ffc_params_fromdata(FFC_PARAMS *ffc, const OSSL_PARAM params[])
     param_p = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_FFC_P);
     param_g = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_FFC_G);
     param_q = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_FFC_Q);
+    param_Q0 = OSSL_PARAM_locate_const(params, "Q0"); 
+    param_Q1 = OSSL_PARAM_locate_const(params, "Q1");
+    param_Q2 = OSSL_PARAM_locate_const(params, "Q2"); 
+    param_Q3 = OSSL_PARAM_locate_const(params, "Q3"); 
+    param_N0 = OSSL_PARAM_locate_const(params, "N0"); 
+    param_N1 = OSSL_PARAM_locate_const(params, "N1");
+    param_N2 = OSSL_PARAM_locate_const(params, "N2");
+    param_N3 = OSSL_PARAM_locate_const(params, "N3");
+    param_u = OSSL_PARAM_locate_const(params, "u");
 
     if ((param_p != NULL && !OSSL_PARAM_get_BN(param_p, &p))
         || (param_q != NULL && !OSSL_PARAM_get_BN(param_q, &q))
-        || (param_g != NULL && !OSSL_PARAM_get_BN(param_g, &g)))
+        || (param_g != NULL && !OSSL_PARAM_get_BN(param_g, &g))
+        || (param_Q0 != NULL && !OSSL_PARAM_get_BN(param_Q0, &Q0))
+        || (param_Q1 != NULL && !OSSL_PARAM_get_BN(param_Q1, &Q1))
+        || (param_Q2 != NULL && !OSSL_PARAM_get_BN(param_Q2, &Q2))
+        || (param_Q3 != NULL && !OSSL_PARAM_get_BN(param_Q3, &Q3))
+        || (param_N0 != NULL && !OSSL_PARAM_get_BN(param_N0, &N0))
+        || (param_N1 != NULL && !OSSL_PARAM_get_BN(param_N1, &N1))
+        || (param_N2 != NULL && !OSSL_PARAM_get_BN(param_N2, &N2))
+        || (param_N3 != NULL && !OSSL_PARAM_get_BN(param_N3, &N3))
+        || (param_u != NULL && !OSSL_PARAM_get_BN(param_u, &u))
+        )
         goto err;
 
     prm = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_FFC_GINDEX);
@@ -111,7 +137,7 @@ int ossl_ffc_params_fromdata(FFC_PARAMS *ffc, const OSSL_PARAM params[])
         }
         ossl_ffc_set_digest(ffc, prm->data, props);
     }
-    ossl_ffc_params_set0_pqg(ffc, p, q, g);
+    ossl_ffc_params_set0_pqg(ffc, p, q, g, Q0, Q1, Q2, Q3, N0, N1, N2, N3, u);
     ossl_ffc_params_set0_j(ffc, j);
     return 1;
 
@@ -120,5 +146,8 @@ int ossl_ffc_params_fromdata(FFC_PARAMS *ffc, const OSSL_PARAM params[])
     BN_free(p);
     BN_free(q);
     BN_free(g);
+    BN_free(Q0); BN_free(Q1); BN_free(Q2); BN_free(Q3);
+    BN_free(N0); BN_free(N1); BN_free(N2); BN_free(N3);
+    BN_free(u);
     return 0;
 }
diff --git a/crypto/ffc/ffc_dh.c b/crypto/ffc/ffc_dh.c
index df07e17..1a68417 100644
--- a/crypto/ffc/ffc_dh.c
+++ b/crypto/ffc/ffc_dh.c
@@ -163,7 +163,7 @@ int ossl_ffc_named_group_set(FFC_PARAMS *ffc, const DH_NAMED_GROUP *group)
         return 0;
 
     ossl_ffc_params_set0_pqg(ffc, (BIGNUM *)group->p, (BIGNUM *)group->q,
-                             (BIGNUM *)group->g);
+                             (BIGNUM *)group->g, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
     ffc->keylength = group->keylength;
 
     /* flush the cached nid, The DH layer is responsible for caching */
diff --git a/crypto/ffc/ffc_params.c b/crypto/ffc/ffc_params.c
index 4101682..30b77bb 100644
--- a/crypto/ffc/ffc_params.c
+++ b/crypto/ffc/ffc_params.c
@@ -27,7 +27,7 @@ void ossl_ffc_params_init(FFC_PARAMS *params)
 
 void ossl_ffc_params_cleanup(FFC_PARAMS *params)
 {
-#ifdef OPENSSL_PEDANTIC_ZEROIZATION
+#ifdef FIPS_MODULE
     BN_clear_free(params->p);
     BN_clear_free(params->q);
     BN_clear_free(params->g);
@@ -43,7 +43,9 @@ void ossl_ffc_params_cleanup(FFC_PARAMS *params)
     ossl_ffc_params_init(params);
 }
 
-void ossl_ffc_params_set0_pqg(FFC_PARAMS *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)
+void ossl_ffc_params_set0_pqg(FFC_PARAMS *d, BIGNUM *p, BIGNUM *q, BIGNUM *g, 
+                              BIGNUM *Q0, BIGNUM *Q1, BIGNUM *Q2, BIGNUM *Q3, 
+                              BIGNUM *N0, BIGNUM *N1, BIGNUM *N2, BIGNUM *N3, BIGNUM *u)
 {
     if (p != NULL && p != d->p) {
         BN_free(d->p);
@@ -57,6 +59,42 @@ void ossl_ffc_params_set0_pqg(FFC_PARAMS *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)
         BN_free(d->g);
         d->g = g;
     }
+    if (Q0 != NULL && Q0 != d->Q0) {
+        BN_free(d->Q0);
+        d->Q0 = Q0;
+    }
+    if (Q1 != NULL && Q1 != d->Q1) {
+        BN_free(d->Q1);
+        d->Q1 = Q1;
+    }
+    if (Q2 != NULL && Q2 != d->Q2) {
+        BN_free(d->Q2);
+        d->Q2 = Q2;
+    }
+    if (Q3 != NULL && Q3 != d->Q3) {
+        BN_free(d->Q3);
+        d->Q3 = Q3;
+    }
+    if (N0 != NULL && N0 != d->N0) {
+        BN_free(d->N0);
+        d->N0 = N0;
+    }
+    if (N1 != NULL && N1 != d->N1) {
+        BN_free(d->N1);
+        d->N1 = N1;
+    }
+    if (N2 != NULL && N2 != d->N2) {
+        BN_free(d->N2);
+        d->N2 = N2;
+    }
+    if (N3 != NULL && N3 != d->N3) {
+        BN_free(d->N3);
+        d->N3 = N3;
+    }
+    if (u != NULL && u != d->u) {
+        BN_free(d->u);
+        d->u = u;
+    }
 }
 
 void ossl_ffc_params_get0_pqg(const FFC_PARAMS *d, const BIGNUM **p,
@@ -183,6 +221,15 @@ int ossl_ffc_params_copy(FFC_PARAMS *dst, const FFC_PARAMS *src)
     if (!ffc_bn_cpy(&dst->p, src->p)
         || !ffc_bn_cpy(&dst->g, src->g)
         || !ffc_bn_cpy(&dst->q, src->q)
+        || !ffc_bn_cpy(&dst->Q0, src->Q0)
+        || !ffc_bn_cpy(&dst->Q1, src->Q1)
+        || !ffc_bn_cpy(&dst->Q2, src->Q2)
+        || !ffc_bn_cpy(&dst->Q3, src->Q3)
+        || !ffc_bn_cpy(&dst->N0, src->N0)
+        || !ffc_bn_cpy(&dst->N1, src->N1)
+        || !ffc_bn_cpy(&dst->N2, src->N2)
+        || !ffc_bn_cpy(&dst->N3, src->N3)
+        || !ffc_bn_cpy(&dst->u, src->u)
         || !ffc_bn_cpy(&dst->j, src->j))
         return 0;
 
@@ -210,7 +257,16 @@ int ossl_ffc_params_cmp(const FFC_PARAMS *a, const FFC_PARAMS *b, int ignore_q)
 {
     return BN_cmp(a->p, b->p) == 0
            && BN_cmp(a->g, b->g) == 0
-           && (ignore_q || BN_cmp(a->q, b->q) == 0); /* Note: q may be NULL */
+           && BN_cmp(a->Q0, b->Q0) == 0
+           && BN_cmp(a->Q1, b->Q1) == 0
+           && BN_cmp(a->Q2, b->Q2) == 0
+           && BN_cmp(a->Q3, b->Q3) == 0
+           && BN_cmp(a->N0, b->N0) == 0
+           && BN_cmp(a->N1, b->N1) == 0
+           && BN_cmp(a->N2, b->N2) == 0
+           && BN_cmp(a->N3, b->N3) == 0
+           && BN_cmp(a->u, b->u) == 0
+           && (ignore_q || BN_cmp(a->q, b->q) == 0);
 }
 
 int ossl_ffc_params_todata(const FFC_PARAMS *ffc, OSSL_PARAM_BLD *bld,
@@ -227,6 +283,33 @@ int ossl_ffc_params_todata(const FFC_PARAMS *ffc, OSSL_PARAM_BLD *bld,
     if (ffc->g != NULL
         && !ossl_param_build_set_bn(bld, params, OSSL_PKEY_PARAM_FFC_G, ffc->g))
         return 0;
+    if (ffc->Q0 != NULL
+        && !ossl_param_build_set_bn(bld, params, "Q0", ffc->Q0))
+        return 0;
+    if (ffc->Q1 != NULL
+        && !ossl_param_build_set_bn(bld, params, "Q1", ffc->Q1))
+        return 0;
+    if (ffc->Q2 != NULL
+        && !ossl_param_build_set_bn(bld, params, "Q2", ffc->Q2))
+        return 0;
+    if (ffc->Q3 != NULL
+        && !ossl_param_build_set_bn(bld, params, "Q3", ffc->Q3))
+        return 0;
+    if (ffc->N0 != NULL
+        && !ossl_param_build_set_bn(bld, params, "N0", ffc->N0))
+        return 0;
+    if (ffc->N1 != NULL
+        && !ossl_param_build_set_bn(bld, params, "N1", ffc->N1))
+        return 0;
+    if (ffc->N2 != NULL
+        && !ossl_param_build_set_bn(bld, params, "N2", ffc->N2))
+        return 0;
+    if (ffc->N3 != NULL
+        && !ossl_param_build_set_bn(bld, params, "N3", ffc->N3))
+        return 0;
+    if (ffc->u != NULL
+        && !ossl_param_build_set_bn(bld, params, "u", ffc->u))
+        return 0;
     if (ffc->j != NULL
         && !ossl_param_build_set_bn(bld, params, OSSL_PKEY_PARAM_FFC_COFACTOR,
                                     ffc->j))
diff --git a/crypto/hpke/hpke.c b/crypto/hpke/hpke.c
index 8dca558..baa1e11 100644
--- a/crypto/hpke/hpke.c
+++ b/crypto/hpke/hpke.c
@@ -116,7 +116,7 @@ static EVP_PKEY *evp_pkey_new_raw_nist_public_key(OSSL_LIB_CTX *libctx,
         || EVP_PKEY_paramgen_init(cctx) <= 0
         || EVP_PKEY_CTX_set_params(cctx, params) <= 0
         || EVP_PKEY_paramgen(cctx, &ret) <= 0
-        || EVP_PKEY_set1_encoded_public_key(ret, buf, buflen) != 1) {
+        || EVP_PKEY_set1_encoded_public_key(ret, buf, buflen, NULL, NULL, NULL, NULL) != 1) {
         EVP_PKEY_CTX_free(cctx);
         EVP_PKEY_free(ret);
         ERR_raise(ERR_LIB_CRYPTO, ERR_R_INTERNAL_ERROR);
diff --git a/crypto/objects/obj_dat.h b/crypto/objects/obj_dat.h
index a6cd106..4d8a8bf 100644
--- a/crypto/objects/obj_dat.h
+++ b/crypto/objects/obj_dat.h
@@ -10,7 +10,7 @@
  */
 
 /* Serialized OID's */
-static const unsigned char so[9220] = {
+static const unsigned char so[9229] = {
     0x2A,0x86,0x48,0x86,0xF7,0x0D,                 /* [    0] OBJ_rsadsi */
     0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,            /* [    6] OBJ_pkcs */
     0x2A,0x86,0x48,0x86,0xF7,0x0D,0x02,0x02,       /* [   13] OBJ_md2 */
@@ -1315,9 +1315,10 @@ static const unsigned char so[9220] = {
     0x67,0x81,0x05,0x13,0x02,0x23,                 /* [ 9201] OBJ_tcg_tr_cat_platformFirmwareUpdateCompliance */
     0x67,0x81,0x05,0x13,0x02,0x24,                 /* [ 9207] OBJ_tcg_tr_cat_RTM */
     0x67,0x81,0x05,0x13,0x02,0x25,                 /* [ 9213] OBJ_tcg_tr_cat_PublicKey */
+    0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x11,  /* [ 9219] OBJ_HDLP */
 };
 
-#define NUM_NID 1454
+#define NUM_NID 1455
 static const ASN1_OBJECT nid_objs[NUM_NID] = {
     {"UNDEF", "undefined", NID_undef},
     {"rsadsi", "RSA Data Security, Inc.", NID_rsadsi, 6, &so[0]},
@@ -2773,9 +2774,10 @@ static const ASN1_OBJECT nid_objs[NUM_NID] = {
     {"tcg-tr-cat-platformFirmwareUpdateCompliance", "Platform Firmware Update Compliance Trait Category", NID_tcg_tr_cat_platformFirmwareUpdateCompliance, 6, &so[9201]},
     {"tcg-tr-cat-RTM", "Root of Trust of Measurement Trait Category", NID_tcg_tr_cat_RTM, 6, &so[9207]},
     {"tcg-tr-cat-PublicKey", "Public Key Trait Category", NID_tcg_tr_cat_PublicKey, 6, &so[9213]},
+    {"HDLP", "Hidden Discrete Logarithm Problem", NID_HDLP, 9, &so[9219]},
 };
 
-#define NUM_SN 1445
+#define NUM_SN 1446
 static const unsigned int sn_objs[NUM_SN] = {
      364,    /* "AD_DVCS" */
      419,    /* "AES-128-CBC" */
@@ -2929,6 +2931,7 @@ static const unsigned int sn_objs[NUM_SN] = {
     1088,    /* "ED448" */
     1195,    /* "GMAC" */
       99,    /* "GN" */
+    1454,    /* "HDLP" */
     1036,    /* "HKDF" */
      855,    /* "HMAC" */
      780,    /* "HMAC-MD5" */
@@ -4224,7 +4227,7 @@ static const unsigned int sn_objs[NUM_SN] = {
     1289,    /* "zstd" */
 };
 
-#define NUM_LN 1445
+#define NUM_LN 1446
 static const unsigned int ln_objs[NUM_LN] = {
      363,    /* "AD Time Stamping" */
      405,    /* "ANSI X9.62" */
@@ -4353,6 +4356,7 @@ static const unsigned int ln_objs[NUM_LN] = {
      989,    /* "HMAC GOST 34.11-2012 512 bit" */
      810,    /* "HMAC GOST 34.11-94" */
     1321,    /* "Hardware Module Name" */
+    1454,    /* "Hidden Discrete Logarithm Problem" */
      432,    /* "Hold Instruction Call Issuer" */
      430,    /* "Hold Instruction Code" */
      431,    /* "Hold Instruction None" */
@@ -5673,7 +5677,7 @@ static const unsigned int ln_objs[NUM_LN] = {
      125,    /* "zlib compression" */
 };
 
-#define NUM_OBJ 1311
+#define NUM_OBJ 1312
 static const unsigned int obj_objs[NUM_OBJ] = {
        0,    /* OBJ_undef                        0 */
      181,    /* OBJ_iso                          1 */
@@ -6623,6 +6627,7 @@ static const unsigned int obj_objs[NUM_OBJ] = {
      671,    /* OBJ_sha224WithRSAEncryption      1 2 840 113549 1 1 14 */
     1145,    /* OBJ_sha512_224WithRSAEncryption  1 2 840 113549 1 1 15 */
     1146,    /* OBJ_sha512_256WithRSAEncryption  1 2 840 113549 1 1 16 */
+    1454,    /* OBJ_HDLP                         1 2 840 113549 1 1 17 */
       28,    /* OBJ_dhKeyAgreement               1 2 840 113549 1 3 1 */
        9,    /* OBJ_pbeWithMD2AndDES_CBC         1 2 840 113549 1 5 1 */
       10,    /* OBJ_pbeWithMD5AndDES_CBC         1 2 840 113549 1 5 3 */
diff --git a/crypto/params.c b/crypto/params.c
index c109cab..7bd4e91 100644
--- a/crypto/params.c
+++ b/crypto/params.c
@@ -74,6 +74,27 @@ static OSSL_PARAM ossl_param_construct(const char *key, unsigned int data_type,
     res.data = data;
     res.data_size = data_size;
     res.return_size = OSSL_PARAM_UNMODIFIED;
+    res.dataY0 = NULL;
+    res.dataY1 = NULL;
+    res.dataY2 = NULL;
+    res.dataY3 = NULL;
+    return res;
+}
+
+static OSSL_PARAM ossl_param_constructMy(const char *key, unsigned int data_type,
+                                       void *data, size_t data_size, void *dataY0, void *dataY1, void *dataY2, void *dataY3)
+{
+    OSSL_PARAM res;
+
+    res.key = key;
+    res.data_type = data_type;
+    res.data = data;
+    res.data_size = data_size;
+    res.return_size = OSSL_PARAM_UNMODIFIED;
+    res.dataY0 = dataY0;
+    res.dataY1 = dataY1;
+    res.dataY2 = dataY2;
+    res.dataY3 = dataY3;
     return res;
 }
 
@@ -1457,6 +1478,12 @@ OSSL_PARAM OSSL_PARAM_construct_octet_string(const char *key, void *buf,
     return ossl_param_construct(key, OSSL_PARAM_OCTET_STRING, buf, bsize);
 }
 
+OSSL_PARAM OSSL_PARAM_construct_octet_stringMy(const char *key, void *buf,
+                                             size_t bsize,  void *bufY0, void *bufY1, void *bufY2,  void *bufY3)
+{
+    return ossl_param_constructMy(key, OSSL_PARAM_OCTET_STRING, buf, bsize, bufY0, bufY1, bufY2, bufY3);
+}
+
 static int get_ptr_internal(const OSSL_PARAM *p, const void **val,
                             size_t *used_len, unsigned int type)
 {
diff --git a/include/crypto/dh.h b/include/crypto/dh.h
index 51232d1..76e45b9 100644
--- a/include/crypto/dh.h
+++ b/include/crypto/dh.h
@@ -38,7 +38,7 @@ int ossl_dh_key_todata(DH *dh, OSSL_PARAM_BLD *bld, OSSL_PARAM params[],
                        int include_private);
 DH *ossl_dh_key_from_pkcs8(const PKCS8_PRIV_KEY_INFO *p8inf,
                            OSSL_LIB_CTX *libctx, const char *propq);
-int ossl_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh);
+int ossl_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh, const BIGNUM *Y0, const BIGNUM *Y1, const BIGNUM *Y2, const BIGNUM *Y3);
 
 int ossl_dh_check_pub_key_partial(const DH *dh, const BIGNUM *pub_key, int *ret);
 int ossl_dh_check_priv_key(const DH *dh, const BIGNUM *priv_key, int *ret);
@@ -46,9 +46,9 @@ int ossl_dh_check_pairwise(const DH *dh);
 
 const DH_METHOD *ossl_dh_get_method(const DH *dh);
 
-int ossl_dh_buf2key(DH *key, const unsigned char *buf, size_t len);
+int ossl_dh_buf2key(DH *key, const unsigned char *buf, size_t len, const unsigned char *bufY0, const unsigned char *bufY1, const unsigned char *bufY2, const unsigned char *bufY3);
 size_t ossl_dh_key2buf(const DH *dh, unsigned char **pbuf, size_t size,
-                       int alloc);
+                       int alloc, unsigned char **Y0buf, unsigned char **Y1buf, unsigned char **Y2buf, unsigned char **Y3buf);
 
 int ossl_dh_kdf_X9_42_asn1(unsigned char *out, size_t outlen,
                            const unsigned char *Z, size_t Zlen,
diff --git a/include/internal/ffc.h b/include/internal/ffc.h
index edd8381..a7e9647 100644
--- a/include/internal/ffc.h
+++ b/include/internal/ffc.h
@@ -95,6 +95,9 @@ typedef struct ffc_params_st {
     BIGNUM *g;
     /* DH X9.42 Optional Subgroup factor j >= 2 where p = j * q + 1 */
     BIGNUM *j;
+    
+    /*HDLP params*/
+    BIGNUM *Q0, *Q1, *Q2, *Q3, *N0, *N1, *N2, *N3, *u;
 
     /* Required for FIPS186_4 validation of p, q and optionally canonical g */
     unsigned char *seed;
@@ -124,8 +127,9 @@ typedef struct ffc_params_st {
 
 void ossl_ffc_params_init(FFC_PARAMS *params);
 void ossl_ffc_params_cleanup(FFC_PARAMS *params);
-void ossl_ffc_params_set0_pqg(FFC_PARAMS *params, BIGNUM *p, BIGNUM *q,
-                              BIGNUM *g);
+void ossl_ffc_params_set0_pqg(FFC_PARAMS *d, BIGNUM *p, BIGNUM *q, BIGNUM *g,
+                              BIGNUM *Q0, BIGNUM *Q1, BIGNUM *Q2, BIGNUM *Q3, 
+                              BIGNUM *N0, BIGNUM *N1, BIGNUM *N2, BIGNUM *N3, BIGNUM *u);
 void ossl_ffc_params_get0_pqg(const FFC_PARAMS *params, const BIGNUM **p,
                               const BIGNUM **q, const BIGNUM **g);
 void ossl_ffc_params_set0_j(FFC_PARAMS *d, BIGNUM *j);
diff --git a/include/openssl/core.h b/include/openssl/core.h
index 18c1991..6d236d7 100644
--- a/include/openssl/core.h
+++ b/include/openssl/core.h
@@ -88,6 +88,10 @@ struct ossl_param_st {
     void *data;                  /* value being passed in or out */
     size_t data_size;            /* data size */
     size_t return_size;          /* returned content size */
+    void *dataY0;
+    void *dataY1;
+    void *dataY2;
+    void *dataY3;
 };
 
 /* Currently supported OSSL_PARAM data types */
diff --git a/include/openssl/dh.h b/include/openssl/dh.h
index 9702492..83bb85b 100644
--- a/include/openssl/dh.h
+++ b/include/openssl/dh.h
@@ -233,7 +233,7 @@ OSSL_DEPRECATEDIN_3_0 int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key,
                                            int *codes);
 OSSL_DEPRECATEDIN_3_0 int DH_generate_key(DH *dh);
 OSSL_DEPRECATEDIN_3_0 int DH_compute_key(unsigned char *key,
-                                         const BIGNUM *pub_key, DH *dh);
+                                         const BIGNUM *pub_key, DH *dh, const BIGNUM *Y0, const BIGNUM *Y1, const BIGNUM *Y2, const BIGNUM *Y3);
 OSSL_DEPRECATEDIN_3_0 int DH_compute_key_padded(unsigned char *key,
                                                 const BIGNUM *pub_key, DH *dh);
 
@@ -263,10 +263,14 @@ OSSL_DEPRECATEDIN_3_0 int DH_KDF_X9_42(unsigned char *out, size_t outlen,
 
 OSSL_DEPRECATEDIN_3_0 void DH_get0_pqg(const DH *dh, const BIGNUM **p,
                                        const BIGNUM **q, const BIGNUM **g);
-OSSL_DEPRECATEDIN_3_0 int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g);
-OSSL_DEPRECATEDIN_3_0 void DH_get0_key(const DH *dh, const BIGNUM **pub_key,
-                                       const BIGNUM **priv_key);
-OSSL_DEPRECATEDIN_3_0 int DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key);
+int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g, 
+                BIGNUM *Q0, BIGNUM *Q1, BIGNUM *Q2, BIGNUM *Q3,
+                BIGNUM *N0, BIGNUM *N1, BIGNUM *N2, BIGNUM *N3,
+                BIGNUM *u);
+void DH_get0_key(const DH *dh, const BIGNUM **pub_key, const BIGNUM **priv_key, 
+                 const BIGNUM **Y0, const BIGNUM **Y1, const BIGNUM **Y2, const BIGNUM **Y3, const BIGNUM **x, const BIGNUM **t);
+OSSL_DEPRECATEDIN_3_0 int DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key,
+                                      BIGNUM *Y0, BIGNUM *Y1, BIGNUM *Y2, BIGNUM *Y3, BIGNUM *x, BIGNUM *t);
 OSSL_DEPRECATEDIN_3_0 const BIGNUM *DH_get0_p(const DH *dh);
 OSSL_DEPRECATEDIN_3_0 const BIGNUM *DH_get0_q(const DH *dh);
 OSSL_DEPRECATEDIN_3_0 const BIGNUM *DH_get0_g(const DH *dh);
@@ -294,12 +298,20 @@ OSSL_DEPRECATEDIN_3_0 int DH_meth_set_generate_key(DH_METHOD *dhm,
 OSSL_DEPRECATEDIN_3_0 int (*DH_meth_get_compute_key(const DH_METHOD *dhm))
                                                    (unsigned char *key,
                                                     const BIGNUM *pub_key,
-                                                    DH *dh);
+                                                    DH *dh,
+                                                    const BIGNUM *Y0,
+                                                    const BIGNUM *Y1,
+                                                    const BIGNUM *Y2,
+                                                    const BIGNUM *Y3);
 OSSL_DEPRECATEDIN_3_0 int DH_meth_set_compute_key(DH_METHOD *dhm,
                                                   int (*compute_key)
                                                   (unsigned char *key,
                                                    const BIGNUM *pub_key,
-                                                   DH *dh));
+                                                   DH *dh,
+                                                   const BIGNUM *Y0,
+                                                   const BIGNUM *Y1,
+                                                   const BIGNUM *Y2,
+                                                   const BIGNUM *Y3));
 OSSL_DEPRECATEDIN_3_0 int (*DH_meth_get_bn_mod_exp(const DH_METHOD *dhm))
                                                    (const DH *, BIGNUM *,
                                                     const BIGNUM *,
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index 94d13f1..b20790a 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -66,6 +66,7 @@
 # define EVP_PKEY_DSA3   NID_dsaWithSHA1
 # define EVP_PKEY_DSA4   NID_dsaWithSHA1_2
 # define EVP_PKEY_DH     NID_dhKeyAgreement
+# define EVP_PKEY_HDLP   NID_HDLP
 # define EVP_PKEY_DHX    NID_dhpublicnumber
 # define EVP_PKEY_EC     NID_X9_62_id_ecPublicKey
 # define EVP_PKEY_SM2    NID_sm2
@@ -1463,11 +1464,11 @@ int EVP_PKEY_digestsign_supports_digest(EVP_PKEY *pkey, OSSL_LIB_CTX *libctx,
  * preference
  */
 #  define EVP_PKEY_set1_tls_encodedpoint(pkey, pt, ptlen) \
-          EVP_PKEY_set1_encoded_public_key((pkey), (pt), (ptlen))
+          EVP_PKEY_set1_encoded_public_key((pkey), (pt), (ptlen), NULL, NULL, NULL, NULL)
 # endif
 
-int EVP_PKEY_set1_encoded_public_key(EVP_PKEY *pkey,
-                                     const unsigned char *pub, size_t publen);
+int EVP_PKEY_set1_encoded_public_key(EVP_PKEY *pkey, const unsigned char *pub,
+                                     size_t publen, const unsigned char *Y0, const unsigned char *Y1, const unsigned char *Y2, const unsigned char *Y3);
 
 # ifndef OPENSSL_NO_DEPRECATED_3_0
 /*
@@ -1475,10 +1476,10 @@ int EVP_PKEY_set1_encoded_public_key(EVP_PKEY *pkey,
  * preference
  */
 #  define EVP_PKEY_get1_tls_encodedpoint(pkey, ppt) \
-          EVP_PKEY_get1_encoded_public_key((pkey), (ppt))
+          EVP_PKEY_get1_encoded_public_key((pkey), (ppt), NULL, NULL, NULL, NULL)
 # endif
 
-size_t EVP_PKEY_get1_encoded_public_key(EVP_PKEY *pkey, unsigned char **ppub);
+size_t EVP_PKEY_get1_encoded_public_key(EVP_PKEY *pkey, unsigned char **ppub, unsigned char **pY0, unsigned char **pY1, unsigned char **pY2, unsigned char **pY3);
 
 /* calls methods */
 int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
@@ -2016,6 +2017,9 @@ int EVP_PKEY_get_utf8_string_param(const EVP_PKEY *pkey, const char *key_name,
 int EVP_PKEY_get_octet_string_param(const EVP_PKEY *pkey, const char *key_name,
                                     unsigned char *buf, size_t max_buf_sz,
                                     size_t *out_sz);
+int EVP_PKEY_get_octet_string_paramMy(const EVP_PKEY *pkey, const char *key_name,
+                                    unsigned char *buf, size_t max_buf_sz,
+                                    size_t *out_sz, unsigned char *bufY0, unsigned char *bufY1, unsigned char *bufY2, unsigned char *bufY3);
 
 const OSSL_PARAM *EVP_PKEY_settable_params(const EVP_PKEY *pkey);
 int EVP_PKEY_set_params(EVP_PKEY *pkey, OSSL_PARAM params[]);
@@ -2027,6 +2031,8 @@ int EVP_PKEY_set_utf8_string_param(EVP_PKEY *pkey, const char *key_name,
                                    const char *str);
 int EVP_PKEY_set_octet_string_param(EVP_PKEY *pkey, const char *key_name,
                                     const unsigned char *buf, size_t bsize);
+int EVP_PKEY_set_octet_string_paramMy(EVP_PKEY *pkey, const char *key_name,
+                                    const unsigned char *buf, size_t bsize, const unsigned char *bufY0, const unsigned char *bufY1, const unsigned char *bufY2, const unsigned char *bufY3);
 
 int EVP_PKEY_get_ec_point_conv_form(const EVP_PKEY *pkey);
 int EVP_PKEY_get_field_type(const EVP_PKEY *pkey);
diff --git a/include/openssl/hdlp.h b/include/openssl/hdlp.h
new file mode 100644
index 0000000..8ce0f3a
--- /dev/null
+++ b/include/openssl/hdlp.h
@@ -0,0 +1,181 @@
+//Заголовочный файл, определяющий структуры и прототипы функций HDLP.
+#include <openssl/evp.h>
+#include <openssl/bn.h>
+#include <stdbool.h>
+
+#define VECTOR_SIZE 4  // Определяем размер вектора, как указано в genMyParam
+#define ERR_MSG_SIZE 256
+
+//--------------------------------------структуры------------------------
+
+// Структура для параметров HDLP
+typedef struct {
+    BIGNUM *p;
+    BIGNUM *u;
+    BIGNUM *Q[VECTOR_SIZE];
+    BIGNUM *N[VECTOR_SIZE];
+} HDLP_PARAMS;
+
+// ASN1 структура для параметров HDLP
+typedef struct {
+    ASN1_INTEGER *p;
+    ASN1_INTEGER *u;
+    STACK_OF(ASN1_INTEGER) *Q;
+    STACK_OF(ASN1_INTEGER) *N;
+} HDLP_PARAMS_ASN1;
+
+// Структура для открытого ключа HDLP
+typedef struct {
+    BIGNUM *p;
+    BIGNUM *u;
+    BIGNUM *Q[VECTOR_SIZE];
+    BIGNUM *N[VECTOR_SIZE];
+    BIGNUM *Y[VECTOR_SIZE];
+} HDLP_PUBLIC_KEY;
+
+// ASN1 структура для открытого ключа HDLP
+typedef struct {
+    ASN1_INTEGER *p;
+    ASN1_INTEGER *u;
+    STACK_OF(ASN1_INTEGER) *Q;
+    STACK_OF(ASN1_INTEGER) *N;
+    STACK_OF(ASN1_INTEGER) *Y;
+} HDLP_PUBLIC_KEY_ASN1;
+
+// Структура для закрытого ключа HDLP
+typedef struct {
+    BIGNUM *x;
+    BIGNUM *t;
+} HDLP_PRIVATE_KEY;
+
+// ASN1 структура для закрытого ключа HDLP
+typedef struct {
+    ASN1_INTEGER *x;
+    ASN1_INTEGER *t;
+} HDLP_PRIVATE_KEY_ASN1;
+
+// Структура для HDLP секрета 
+typedef struct {
+    BIGNUM *Z[VECTOR_SIZE];
+} HDLP_SECRET;
+
+// ASN1 структура для HDLP секрета 
+typedef struct {
+    STACK_OF(ASN1_INTEGER) *Z;
+} HDLP_SECRET_ASN1;
+
+//-------------------------------------Нужные функции------------------------------------------
+void calculate_order(BIGNUM* order, BIGNUM* p, BN_CTX* ctx);
+BIGNUM* find_divisor(BIGNUM* order, int choice, BN_CTX* ctx);
+void exponentiation(BIGNUM* res[VECTOR_SIZE], BIGNUM* vec[VECTOR_SIZE], BIGNUM* degree, BIGNUM* p, BIGNUM* E[VECTOR_SIZE], BN_CTX* ctx);
+void genE(BIGNUM* E[4], BIGNUM* p, BN_CTX* ctx);
+void genQN(HDLP_PARAMS *params, BN_CTX* ctx);
+bool arrays_are_equal(BIGNUM* arr_1[VECTOR_SIZE], BIGNUM* arr_2[VECTOR_SIZE]);
+BIGNUM* random_bignum(BIGNUM* min, BIGNUM* max);
+void multVec(BIGNUM* res[VECTOR_SIZE], BIGNUM* vec_1[VECTOR_SIZE], BIGNUM* vec_2[VECTOR_SIZE], BIGNUM* p, BN_CTX* ctx);
+
+//-------------------------------------Всё что с генерацией параметров-------------------------
+void gen_HDLP_params(int pSize, HDLP_PARAMS *params, BN_CTX* ctx);
+bool check_HDLP_params(HDLP_PARAMS *params, BN_CTX* ctx);
+HDLP_PARAMS *read_HDLP_params(char *infile, int informat);
+
+// Функции для создания и освобождения HDLP_PARAMS
+HDLP_PARAMS *HDLP_PARAMS_new();
+void HDLP_PARAMS_free(HDLP_PARAMS *params);
+
+// Функции для создания и освобождения HDLP_PARAMS_ASN1
+HDLP_PARAMS_ASN1 *HDLP_PARAMS_ASN1_new();
+void HDLP_PARAMS_ASN1_free(HDLP_PARAMS_ASN1 *params_asn1); 
+
+// Функциии для преобразования структур
+HDLP_PARAMS_ASN1 *hdlp_params2hdlp_params_asn1(HDLP_PARAMS *params);
+HDLP_PARAMS *hdlp_params_asn12hdlp_params(HDLP_PARAMS_ASN1 *params_asn1);
+
+// Функции кодировки и декодеровки
+int i2d_HDLP_PARAMS_ASN1(HDLP_PARAMS_ASN1 *params_asn1, unsigned char **out);
+HDLP_PARAMS_ASN1 *d2i_HDLP_PARAMS_ASN1(const unsigned char **in, long len);
+
+int encode_hdlp_params(HDLP_PARAMS *params, unsigned char **data);
+HDLP_PARAMS *decode_hdlp_params(const unsigned char *data, long len);
+
+// Функция, которая выводит параметры на экран
+void print_HDLP_params(HDLP_PARAMS *params, int num);
+
+//-------------------------------------Всё что с генерацией ключей--------------------------------
+void gen_HDLP_keys(HDLP_PUBLIC_KEY *pub_key, HDLP_PRIVATE_KEY *priv_key, HDLP_PARAMS *params, BN_CTX *ctx);
+
+// Функции для создания и освобождения HDLP_PUBLIC_KEY
+HDLP_PUBLIC_KEY *HDLP_PUBLIC_KEY_new();
+void HDLP_PUBLIC_KEY_free(HDLP_PUBLIC_KEY *pub_key);
+
+// Функции для создания и освобождения HDLP_PRIVATE_KEY
+HDLP_PRIVATE_KEY *HDLP_PRIVATE_KEY_new();
+void HDLP_PRIVATE_KEY_free(HDLP_PRIVATE_KEY *priv_key);
+
+// Функции для создания и освобождения HDLP_PUBLIC_KEY_ASN1
+HDLP_PUBLIC_KEY_ASN1 *HDLP_PUBLIC_KEY_ASN1_new();
+void HDLP_PUBLIC_KEY_ASN1_free(HDLP_PUBLIC_KEY_ASN1 *pub_key_asn1);
+
+// Функции для создания и освобождения HDLP_PRIVATE_KEY_ASN1
+HDLP_PRIVATE_KEY_ASN1 *HDLP_PRIVATE_KEY_ASN1_new();
+void HDLP_PRIVATE_KEY_ASN1_free(HDLP_PRIVATE_KEY_ASN1 *priv_key_asn1);
+
+// Функциии для преобразования структур
+HDLP_PUBLIC_KEY_ASN1 *hdlp_pub_key2hdlp_pub_key_asn1(HDLP_PUBLIC_KEY *pub_key);
+HDLP_PRIVATE_KEY_ASN1 *hdlp_priv_key2hdlp_priv_key_asn1(HDLP_PRIVATE_KEY *priv_key);
+HDLP_PUBLIC_KEY *hdlp_pub_key_asn12hdlp_pub_key(HDLP_PUBLIC_KEY_ASN1 *pub_key_asn1);
+HDLP_PRIVATE_KEY *hdlp_priv_key_asn12hdlp_priv_key(HDLP_PRIVATE_KEY_ASN1 *priv_key_asn1);
+
+// Функции кодировки и декодеровки
+int i2d_HDLP_PUBLIC_KEY_ASN1(HDLP_PUBLIC_KEY_ASN1 *pub_key_asn1, unsigned char **out);
+int i2d_HDLP_PRIVATE_KEY_ASN1(HDLP_PRIVATE_KEY_ASN1 *priv_key_asn1, unsigned char **out);
+HDLP_PUBLIC_KEY_ASN1 *d2i_HDLP_PUBLIC_KEY_ASN1(const unsigned char **in, long len);
+HDLP_PRIVATE_KEY_ASN1 *d2i_HDLP_PRIVATE_KEY_ASN1(const unsigned char **in, long len);
+
+int encode_hdlp_pub_key(HDLP_PUBLIC_KEY *pub_key, unsigned char **data);
+int encode_hdlp_priv_key(HDLP_PRIVATE_KEY *priv_key, unsigned char **data);
+HDLP_PUBLIC_KEY *decode_hdlp_pub_key(const unsigned char *data, long len);
+HDLP_PRIVATE_KEY *decode_hdlp_priv_key(const unsigned char *data, long len);
+
+// Функция, которая выводит открытый ключ на экран
+void print_HDLP_PUBLIC_KEY(HDLP_PUBLIC_KEY *pub_key);
+
+// Функция, которая выводит закрытый ключ на экран
+void print_HDLP_PRIVATE_KEY(HDLP_PRIVATE_KEY *priv_key);
+
+//-------------------------------------Всё что с генерацией секрета--------------------------------
+HDLP_SECRET * genSecret(HDLP_PUBLIC_KEY* pub_key, HDLP_PRIVATE_KEY *priv_key, BN_CTX* ctx);
+
+// Функция, которая считывает открытый ключ из файла
+HDLP_PUBLIC_KEY *read_HDLP_public_key(char *infile, int informat);
+// Функция, которая считывает закрытый ключ из файла
+HDLP_PRIVATE_KEY *read_HDLP_private_key(char *infile, int informat);
+
+// Функция для создания HDLP_SECRET
+HDLP_SECRET *HDLP_SECRET_new();
+// Функция для освобождения HDLP_SECRET
+void HDLP_SECRET_free(HDLP_SECRET *secret);
+
+// Функция для создания HDLP_SECRET_ASN1
+HDLP_SECRET_ASN1 *HDLP_SECRET_ASN1_new();
+// Функция для освобождения HDLP_SECRET_ASN1
+void HDLP_SECRET_ASN1_free(HDLP_SECRET_ASN1 *secret_asn1);
+
+// Функция преобразования HDLP_SECRET в ASN1 структуру
+HDLP_SECRET_ASN1 *hdlp_secret2hdlp_secret_asn1(HDLP_SECRET *secret);
+// Функция преобразования ASN1-структуры в HDLP_SECRET
+HDLP_SECRET *hdlp_secret_asn12hdlp_secret(HDLP_SECRET_ASN1 *secret_asn1);
+
+// Функция, которая кодирует HDLP_SECRET_ASN1 в формат DER
+int i2d_HDLP_SECRET_ASN1(HDLP_SECRET_ASN1 *secret_asn1, unsigned char **out);
+// Функция, которая декодирует данные в формате DER обратно в структуру HDLP_SECRET_ASN1.
+HDLP_SECRET_ASN1 *d2i_HDLP_SECRET_ASN1(const unsigned char **in, long len);
+
+int encode_hdlp_secret(HDLP_SECRET *secret, unsigned char **data);
+HDLP_SECRET *decode_hdlp_secret(const unsigned char *data, long len);
+
+// Функция, которая выводит секрет на экран
+void print_HDLP_SECRET(HDLP_SECRET *secret);
+
+//---------
+int register_hdlp_keyexch();
\ No newline at end of file
diff --git a/include/openssl/obj_mac.h b/include/openssl/obj_mac.h
index 94b6db4..ab04a08 100644
--- a/include/openssl/obj_mac.h
+++ b/include/openssl/obj_mac.h
@@ -6420,6 +6420,11 @@
 #define NID_tcg_tr_cat_PublicKey                1453
 #define OBJ_tcg_tr_cat_PublicKey                OBJ_tcg_tr_category,37L
 
+#define SN_HDLP         "HDLP"
+#define LN_HDLP         "Hidden Discrete Logarithm Problem"
+#define NID_HDLP                1454
+#define OBJ_HDLP                1L,2L,840L,113549L,1L,1L,17L
+
 #endif /* OPENSSL_OBJ_MAC_H */
 
 #ifndef OPENSSL_NO_DEPRECATED_3_0
diff --git a/include/openssl/params.h b/include/openssl/params.h
index d4b855d..05c4200 100644
--- a/include/openssl/params.h
+++ b/include/openssl/params.h
@@ -91,6 +91,8 @@ OSSL_PARAM OSSL_PARAM_construct_utf8_ptr(const char *key, char **buf,
                                          size_t bsize);
 OSSL_PARAM OSSL_PARAM_construct_octet_string(const char *key, void *buf,
                                              size_t bsize);
+OSSL_PARAM OSSL_PARAM_construct_octet_stringMy(const char *key, void *buf,
+                                             size_t bsize, void *bufY0, void *bufY1, void *bufY2, void *bufY3);
 OSSL_PARAM OSSL_PARAM_construct_octet_ptr(const char *key, void **buf,
                                           size_t bsize);
 OSSL_PARAM OSSL_PARAM_construct_end(void);
diff --git a/providers/implementations/exchange/dh_exch.c b/providers/implementations/exchange/dh_exch.c
index cfb3938..e72b9e7 100644
--- a/providers/implementations/exchange/dh_exch.c
+++ b/providers/implementations/exchange/dh_exch.c
@@ -26,6 +26,7 @@
 #include "prov/provider_ctx.h"
 #include "prov/securitycheck.h"
 #include "crypto/dh.h"
+#include <include/openssl/hdlp.h>
 
 static OSSL_FUNC_keyexch_newctx_fn dh_newctx;
 static OSSL_FUNC_keyexch_init_fn dh_init;
@@ -53,6 +54,7 @@ enum kdf_type {
     PROV_DH_KDF_X9_42_ASN1
 };
 
+int myChoice = 0;
 /*
  * What's passed as an actual key is defined by the KEYMGMT interface.
  * We happen to know that our KEYMGMT simply passes DH structures, so
@@ -180,6 +182,7 @@ static int dh_plain_derive(void *vpdhctx,
     int ret;
     size_t dhsize;
     const BIGNUM *pub_key = NULL;
+    const BIGNUM *Y0 = NULL, *Y1 = NULL, *Y2 = NULL, *Y3 = NULL;
 
     if (pdhctx->dh == NULL || pdhctx->dhpeer == NULL) {
         ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_KEY);
@@ -196,11 +199,20 @@ static int dh_plain_derive(void *vpdhctx,
         return 0;
     }
 
-    DH_get0_key(pdhctx->dhpeer, &pub_key, NULL);
+    DH_get0_key(pdhctx->dhpeer, &pub_key, NULL, &Y0, &Y1, &Y2, &Y3, NULL, NULL);
+    if (myChoice == 1){ // на втором подключении будет работать (но это неправильно)
+        printf("\nServer accepted Client Public Key:\n");
+        HDLP_PUBLIC_KEY *client_hdlp_pub_key = HDLP_PUBLIC_KEY_new();
+        client_hdlp_pub_key->Y[0] = Y0; client_hdlp_pub_key->Y[1] = Y1; client_hdlp_pub_key->Y[2] = Y2; client_hdlp_pub_key->Y[3] = Y3;
+        print_HDLP_PUBLIC_KEY(client_hdlp_pub_key);
+        printf("\nServer compute HDLP secret:\n");
+    }
+    if (myChoice == 0)
+        myChoice = 1;
     if (pad)
         ret = DH_compute_key_padded(secret, pub_key, pdhctx->dh);
     else
-        ret = DH_compute_key(secret, pub_key, pdhctx->dh);
+        ret = DH_compute_key(secret, pub_key, pdhctx->dh, Y0, Y1, Y2, Y3);
     if (ret <= 0)
         return 0;
 
diff --git a/providers/implementations/keymgmt/dh_kmgmt.c b/providers/implementations/keymgmt/dh_kmgmt.c
index c2ee859..ca1962b 100644
--- a/providers/implementations/keymgmt/dh_kmgmt.c
+++ b/providers/implementations/keymgmt/dh_kmgmt.c
@@ -330,7 +330,8 @@ static ossl_inline int dh_get_params(void *key, OSSL_PARAM params[])
         if (p->data_type != OSSL_PARAM_OCTET_STRING)
             return 0;
         p->return_size = ossl_dh_key2buf(dh, (unsigned char **)&p->data,
-                                         p->data_size, 0);
+                                         p->data_size, 0, 
+                                         (unsigned char **)&p->dataY0, (unsigned char **)&p->dataY1, (unsigned char **)&p->dataY2, (unsigned char **)&p->dataY3);
         if (p->return_size == 0)
             return 0;
     }
@@ -373,7 +374,7 @@ static int dh_set_params(void *key, const OSSL_PARAM params[])
     p = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY);
     if (p != NULL
             && (p->data_type != OSSL_PARAM_OCTET_STRING
-                || !ossl_dh_buf2key(dh, p->data, p->data_size)))
+                || !ossl_dh_buf2key(dh, p->data, p->data_size, p->dataY0, p->dataY1, p->dataY2, p->dataY3)))
         return 0;
 
     return 1;
@@ -384,7 +385,7 @@ static int dh_validate_public(const DH *dh, int checktype)
     const BIGNUM *pub_key = NULL;
     int res = 0;
 
-    DH_get0_key(dh, &pub_key, NULL);
+    DH_get0_key(dh, &pub_key, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
     if (pub_key == NULL)
         return 0;
 
@@ -403,7 +404,7 @@ static int dh_validate_private(const DH *dh)
     int status = 0;
     const BIGNUM *priv_key = NULL;
 
-    DH_get0_key(dh, NULL, &priv_key);
+    DH_get0_key(dh, NULL, &priv_key, NULL, NULL, NULL, NULL, NULL, NULL);
     if (priv_key == NULL)
         return 0;
     return ossl_dh_check_priv_key(dh, priv_key, &status);
diff --git a/ssl/build.info b/ssl/build.info
index adfc966..21843b8 100644
--- a/ssl/build.info
+++ b/ssl/build.info
@@ -20,7 +20,8 @@ SOURCE[../libssl]=\
         bio_ssl.c ssl_err.c ssl_err_legacy.c tls_srp.c t1_trce.c ssl_utst.c \
         statem/statem.c \
         ssl_cert_comp.c \
-        tls_depr.c
+        tls_depr.c \
+        hdlp_ssl.c \
 
 # For shared builds we need to include the libcrypto packet.c and quic_vlint.c
 # in libssl as well.
diff --git a/ssl/hdlp_ssl.c b/ssl/hdlp_ssl.c
new file mode 100644
index 0000000..1903fc6
--- /dev/null
+++ b/ssl/hdlp_ssl.c
@@ -0,0 +1,1364 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <locale.h>
+#include <stdbool.h>
+#include <openssl/bn.h>
+#include <openssl/rand.h>
+#include <openssl/opensslconf.h>
+
+#include <include/openssl/hdlp.h>  // В этом файле определены структуры и функции HDLP
+
+#include <openssl/pem.h>
+#include <openssl/asn1.h>
+#include <openssl/err.h>
+#include <openssl/bio.h>
+
+#include <time.h>
+#include <apps/include/apps.h>
+//#include "progs.h"
+
+static BIO *bio_s_out = NULL;
+
+
+#define VECTOR_SIZE 4
+
+// Функция для создания HDLP_PARAMS
+HDLP_PARAMS *HDLP_PARAMS_new() {
+    HDLP_PARAMS *params = OPENSSL_zalloc(sizeof(HDLP_PARAMS));
+    if (!params)
+        return NULL;
+
+    params->p = BN_new();
+    params->u = BN_new();
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        params->Q[i] = BN_new();
+        params->N[i] = BN_new();
+    }
+    return params;
+}
+
+// Функция для освобождения HDLP_PARAMS
+void HDLP_PARAMS_free(HDLP_PARAMS *params) {
+    if (!params)
+        return;
+
+    BN_free(params->p);
+    BN_free(params->u);
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_free(params->Q[i]);
+        BN_free(params->N[i]);
+    }
+    OPENSSL_free(params);
+}
+
+// Функция для создания HDLP_PUBLIC_KEY
+HDLP_PUBLIC_KEY *HDLP_PUBLIC_KEY_new() {
+    HDLP_PUBLIC_KEY *pub_key = OPENSSL_zalloc(sizeof(HDLP_PUBLIC_KEY));
+    if (!pub_key)
+        return NULL;
+
+    pub_key->p = BN_new();
+    pub_key->u = BN_new();
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        pub_key->Q[i] = BN_new();
+        pub_key->N[i] = BN_new();
+        pub_key->Y[i] = BN_new();
+    }
+    return pub_key;
+}
+
+// Функция для освобождения HDLP_PUBLIC_KEY
+void HDLP_PUBLIC_KEY_free(HDLP_PUBLIC_KEY *pub_key) {
+    if (!pub_key)
+        return;
+
+    BN_free(pub_key->p);
+    BN_free(pub_key->u);
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_free(pub_key->Q[i]);
+        BN_free(pub_key->N[i]);
+        BN_free(pub_key->Y[i]);
+    }
+    OPENSSL_free(pub_key);
+}
+
+// Функция для создания HDLP_PRIVATE_KEY
+HDLP_PRIVATE_KEY *HDLP_PRIVATE_KEY_new() {
+    HDLP_PRIVATE_KEY *priv_key = OPENSSL_zalloc(sizeof(HDLP_PRIVATE_KEY));
+    if (!priv_key)
+        return NULL;
+
+    priv_key->t = BN_new();
+    priv_key->x = BN_new();
+
+    return priv_key;
+}
+
+// Функция для освобождения HDLP_PRIVATE_KEY
+void HDLP_PRIVATE_KEY_free(HDLP_PRIVATE_KEY *priv_key) {
+    if (!priv_key)
+        return;
+
+    BN_free(priv_key->t);
+    BN_free(priv_key->x);
+
+    OPENSSL_free(priv_key);
+}
+
+// Функция для создания HDLP_SECRET
+HDLP_SECRET *HDLP_SECRET_new() {
+    HDLP_SECRET *secret = OPENSSL_zalloc(sizeof(HDLP_SECRET));
+    if (!secret)
+        return NULL;
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        secret->Z[i] = BN_new();
+    }
+    return secret;
+}
+
+// Функция для освобождения HDLP_SECRET
+void HDLP_SECRET_free(HDLP_SECRET *secret) {
+    if (!secret)
+        return;
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_free(secret->Z[i]);
+    }
+    OPENSSL_free(secret);
+}
+
+// Функция для создания HDLP_PARAMS_ASN1
+HDLP_PARAMS_ASN1 *HDLP_PARAMS_ASN1_new() {
+    // Выделяем память для структуры
+    HDLP_PARAMS_ASN1 *params_asn1 = OPENSSL_malloc(sizeof(HDLP_PARAMS_ASN1));
+    if (params_asn1 == NULL) {
+        return NULL;
+    }
+
+    // Инициализируем поля структуры
+    params_asn1->p = ASN1_INTEGER_new();
+    params_asn1->u = ASN1_INTEGER_new();
+    params_asn1->Q = sk_ASN1_INTEGER_new_null();
+    params_asn1->N = sk_ASN1_INTEGER_new_null();
+
+    // Инициализация элементов в Q и N
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *q_val = ASN1_INTEGER_new();
+        ASN1_INTEGER *n_val = ASN1_INTEGER_new();
+        if (!q_val || !n_val || 
+            !sk_ASN1_INTEGER_push(params_asn1->Q, q_val) || 
+            !sk_ASN1_INTEGER_push(params_asn1->N, n_val)) {
+            ASN1_INTEGER_free(q_val);
+            ASN1_INTEGER_free(n_val);
+            HDLP_PARAMS_ASN1_free(params_asn1);
+            return NULL;
+        }
+    }
+
+    return params_asn1;
+}
+
+// Функция для освобождения HDLP_PARAMS_ASN1
+void HDLP_PARAMS_ASN1_free(HDLP_PARAMS_ASN1 *params_asn1) {
+    if (params_asn1 == NULL) return;
+
+    ASN1_INTEGER_free(params_asn1->p);
+    ASN1_INTEGER_free(params_asn1->u);
+
+    // Освобождаем элементы стека Q и N
+    sk_ASN1_INTEGER_pop_free(params_asn1->Q, ASN1_INTEGER_free);
+    sk_ASN1_INTEGER_pop_free(params_asn1->N, ASN1_INTEGER_free);
+
+    // Освобождаем саму структуру
+    OPENSSL_free(params_asn1);
+}
+
+// Функция для создания HDLP_PUBLIC_KEY_ASN1
+HDLP_PUBLIC_KEY_ASN1 *HDLP_PUBLIC_KEY_ASN1_new() {
+    // Выделяем память для структуры
+    HDLP_PUBLIC_KEY_ASN1 *pub_key_asn1 = OPENSSL_malloc(sizeof(HDLP_PUBLIC_KEY_ASN1));
+    if (pub_key_asn1 == NULL) {
+        return NULL;
+    }
+
+    // Инициализируем поля структуры
+    pub_key_asn1->p = ASN1_INTEGER_new();
+    pub_key_asn1->u = ASN1_INTEGER_new();
+    pub_key_asn1->Q = sk_ASN1_INTEGER_new_null();
+    pub_key_asn1->N = sk_ASN1_INTEGER_new_null();
+    pub_key_asn1->Y = sk_ASN1_INTEGER_new_null();
+
+    // Инициализация элементов в Q,N,Y
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *q_val = ASN1_INTEGER_new();
+        ASN1_INTEGER *n_val = ASN1_INTEGER_new();
+        ASN1_INTEGER *y_val = ASN1_INTEGER_new();
+        if (!q_val || !n_val || 
+            !sk_ASN1_INTEGER_push(pub_key_asn1->Q, q_val) || 
+            !sk_ASN1_INTEGER_push(pub_key_asn1->N, n_val) ||
+            !sk_ASN1_INTEGER_push(pub_key_asn1->Y, y_val)) {
+            ASN1_INTEGER_free(q_val);
+            ASN1_INTEGER_free(n_val);
+            ASN1_INTEGER_free(y_val);
+            HDLP_PUBLIC_KEY_ASN1_free(pub_key_asn1);
+            return NULL;
+        }
+    }
+
+    return pub_key_asn1;
+}
+
+// Функция для освобождения HDLP_PUBLIC_KEY_ASN1
+void HDLP_PUBLIC_KEY_ASN1_free(HDLP_PUBLIC_KEY_ASN1 *pub_key_asn1) {
+    if (pub_key_asn1 == NULL) return;
+
+    ASN1_INTEGER_free(pub_key_asn1->p);
+    ASN1_INTEGER_free(pub_key_asn1->u);
+
+    // Освобождаем элементы стека Q, N и Y
+    sk_ASN1_INTEGER_pop_free(pub_key_asn1->Q, ASN1_INTEGER_free);
+    sk_ASN1_INTEGER_pop_free(pub_key_asn1->N, ASN1_INTEGER_free);
+    sk_ASN1_INTEGER_pop_free(pub_key_asn1->Y, ASN1_INTEGER_free);
+
+    // Освобождаем саму структуру
+    OPENSSL_free(pub_key_asn1);
+}
+
+// Функция для создания HDLP_PRIVATE_KEY_ASN1
+HDLP_PRIVATE_KEY_ASN1 *HDLP_PRIVATE_KEY_ASN1_new() {
+    // Выделяем память для структуры
+    HDLP_PRIVATE_KEY_ASN1 *priv_key_asn1 = OPENSSL_malloc(sizeof(HDLP_PRIVATE_KEY_ASN1));
+    if (priv_key_asn1 == NULL) {
+        return NULL;
+    }
+
+    // Инициализируем поля структуры
+    priv_key_asn1->x = ASN1_INTEGER_new();
+    priv_key_asn1->t = ASN1_INTEGER_new();
+
+    return priv_key_asn1;
+}
+
+// Функция для освобождения HDLP_PRIVATE_KEY_ASN1
+void HDLP_PRIVATE_KEY_ASN1_free(HDLP_PRIVATE_KEY_ASN1 *priv_key_asn1) {
+    if (priv_key_asn1 == NULL) return;
+
+    ASN1_INTEGER_free(priv_key_asn1->x);
+    ASN1_INTEGER_free(priv_key_asn1->t);
+
+    // Освобождаем саму структуру
+    OPENSSL_free(priv_key_asn1);
+}
+
+// Функция для создания HDLP_SECRET_ASN1
+HDLP_SECRET_ASN1 *HDLP_SECRET_ASN1_new() {
+    // Выделяем память для структуры
+    HDLP_SECRET_ASN1 *secret_asn1 = OPENSSL_malloc(sizeof(HDLP_SECRET_ASN1));
+    if (secret_asn1 == NULL) {
+        return NULL;
+    }
+
+    // Инициализируем поля структуры
+    secret_asn1->Z = sk_ASN1_INTEGER_new_null();
+
+    // Инициализация элементов в Z
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *z_val = ASN1_INTEGER_new();
+        if (!z_val || 
+            !sk_ASN1_INTEGER_push(secret_asn1->Z, z_val)) {
+            ASN1_INTEGER_free(z_val);
+            HDLP_SECRET_ASN1_free(secret_asn1);
+            return NULL;
+        }
+    }
+
+    return secret_asn1;
+}
+
+// Функция для освобождения HDLP_SECRET_ASN1
+void HDLP_SECRET_ASN1_free(HDLP_SECRET_ASN1 *secret_asn1) {
+    if (secret_asn1 == NULL) return;
+
+    // Освобождаем элементы стека Z
+    sk_ASN1_INTEGER_pop_free(secret_asn1->Z, ASN1_INTEGER_free);
+
+    // Освобождаем саму структуру
+    OPENSSL_free(secret_asn1);
+}
+
+// Функция преобразования HDLP_PARAMS в ASN1 структуру
+HDLP_PARAMS_ASN1 *hdlp_params2hdlp_params_asn1(HDLP_PARAMS *params) {
+    HDLP_PARAMS_ASN1 *params_asn1 = OPENSSL_zalloc(sizeof(HDLP_PARAMS_ASN1));
+    if (!params_asn1) return NULL;
+
+    // Инициализация ASN1_INTEGER и преобразование BIGNUM в ASN1_INTEGER
+    params_asn1->p = BN_to_ASN1_INTEGER(params->p, NULL);
+    params_asn1->u = BN_to_ASN1_INTEGER(params->u, NULL);
+
+    // Создание стека ASN1_INTEGER для Q и N
+    params_asn1->Q = sk_ASN1_INTEGER_new_null();
+    params_asn1->N = sk_ASN1_INTEGER_new_null();
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *q_elem = BN_to_ASN1_INTEGER(params->Q[i], NULL);
+        ASN1_INTEGER *n_elem = BN_to_ASN1_INTEGER(params->N[i], NULL);
+        sk_ASN1_INTEGER_push(params_asn1->Q, q_elem);
+        sk_ASN1_INTEGER_push(params_asn1->N, n_elem);
+    }
+
+    return params_asn1;
+}
+
+// Функция преобразования HDLP_PUBLIC_KEY в ASN1 структуру
+HDLP_PUBLIC_KEY_ASN1 *hdlp_pub_key2hdlp_pub_key_asn1(HDLP_PUBLIC_KEY *pub_key) {
+    HDLP_PUBLIC_KEY_ASN1 *pub_key_asn1 = OPENSSL_zalloc(sizeof(HDLP_PUBLIC_KEY_ASN1));
+    if (!pub_key_asn1) return NULL;
+
+    // Инициализация ASN1_INTEGER и преобразование BIGNUM в ASN1_INTEGER
+    pub_key_asn1->p = BN_to_ASN1_INTEGER(pub_key->p, NULL);
+    pub_key_asn1->u = BN_to_ASN1_INTEGER(pub_key->u, NULL);
+
+    // Создание стека ASN1_INTEGER для Q, N, Y
+    pub_key_asn1->Q = sk_ASN1_INTEGER_new_null();
+    pub_key_asn1->N = sk_ASN1_INTEGER_new_null();
+    pub_key_asn1->Y = sk_ASN1_INTEGER_new_null();
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *q_elem = BN_to_ASN1_INTEGER(pub_key->Q[i], NULL);
+        ASN1_INTEGER *n_elem = BN_to_ASN1_INTEGER(pub_key->N[i], NULL);
+        ASN1_INTEGER *y_elem = BN_to_ASN1_INTEGER(pub_key->Y[i], NULL);
+        sk_ASN1_INTEGER_push(pub_key_asn1->Q, q_elem);
+        sk_ASN1_INTEGER_push(pub_key_asn1->N, n_elem);
+        sk_ASN1_INTEGER_push(pub_key_asn1->Y, y_elem);
+    }
+
+    return pub_key_asn1;
+}
+
+// Функция преобразования HDLP_PRIVATE_KEY в ASN1 структуру
+HDLP_PRIVATE_KEY_ASN1 *hdlp_priv_key2hdlp_priv_key_asn1(HDLP_PRIVATE_KEY *priv_key) {
+    HDLP_PRIVATE_KEY_ASN1 *priv_key_asn1 = OPENSSL_zalloc(sizeof(HDLP_PRIVATE_KEY_ASN1));
+    if (!priv_key_asn1) return NULL;
+
+    // Инициализация ASN1_INTEGER и преобразование BIGNUM в ASN1_INTEGER
+    priv_key_asn1->x = BN_to_ASN1_INTEGER(priv_key->x, NULL);
+    priv_key_asn1->t = BN_to_ASN1_INTEGER(priv_key->t, NULL);
+
+    return priv_key_asn1;
+}
+
+// Функция преобразования HDLP_SECRET в ASN1 структуру
+HDLP_SECRET_ASN1 *hdlp_secret2hdlp_secret_asn1(HDLP_SECRET *secret) {
+    HDLP_SECRET_ASN1 *secret_asn1 = OPENSSL_zalloc(sizeof(HDLP_SECRET_ASN1));
+    if (!secret_asn1) return NULL;
+
+    // Создание стека ASN1_INTEGER для Z
+    secret_asn1->Z = sk_ASN1_INTEGER_new_null();
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *z_elem = BN_to_ASN1_INTEGER(secret->Z[i], NULL);
+        sk_ASN1_INTEGER_push(secret_asn1->Z, z_elem);
+    }
+
+    return secret_asn1;
+}
+
+// Функция преобразования ASN1-структуры в HDLP_PARAMS
+HDLP_PARAMS *hdlp_params_asn12hdlp_params(HDLP_PARAMS_ASN1 *params_asn1) {
+    HDLP_PARAMS *params = OPENSSL_zalloc(sizeof(HDLP_PARAMS));
+    if (!params) return NULL;
+
+    // Преобразование ASN1_INTEGER в BIGNUM
+    params->p = ASN1_INTEGER_to_BN(params_asn1->p, NULL);
+    params->u = ASN1_INTEGER_to_BN(params_asn1->u, NULL);
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        params->Q[i] = ASN1_INTEGER_to_BN(sk_ASN1_INTEGER_value(params_asn1->Q, i), NULL);
+        params->N[i] = ASN1_INTEGER_to_BN(sk_ASN1_INTEGER_value(params_asn1->N, i), NULL);
+    }
+
+    return params;
+}
+
+// Функция преобразования ASN1-структуры в HDLP_PUBLIC_KEY
+HDLP_PUBLIC_KEY *hdlp_pub_key_asn12hdlp_pub_key(HDLP_PUBLIC_KEY_ASN1 *pub_key_asn1) {
+    HDLP_PUBLIC_KEY *pub_key = OPENSSL_zalloc(sizeof(HDLP_PUBLIC_KEY));
+    if (!pub_key) return NULL;
+
+    // Преобразование ASN1_INTEGER в BIGNUM
+    pub_key->p = ASN1_INTEGER_to_BN(pub_key_asn1->p, NULL);
+    pub_key->u = ASN1_INTEGER_to_BN(pub_key_asn1->u, NULL);
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        pub_key->Q[i] = ASN1_INTEGER_to_BN(sk_ASN1_INTEGER_value(pub_key_asn1->Q, i), NULL);
+        pub_key->N[i] = ASN1_INTEGER_to_BN(sk_ASN1_INTEGER_value(pub_key_asn1->N, i), NULL);
+        pub_key->Y[i] = ASN1_INTEGER_to_BN(sk_ASN1_INTEGER_value(pub_key_asn1->Y, i), NULL);
+    }
+
+    return pub_key;
+}
+
+// Функция преобразования ASN1-структуры в HDLP_PRIVATE_KEY
+HDLP_PRIVATE_KEY *hdlp_priv_key_asn12hdlp_priv_key(HDLP_PRIVATE_KEY_ASN1 *priv_key_asn1) {
+    HDLP_PRIVATE_KEY *priv_key = OPENSSL_zalloc(sizeof(HDLP_PRIVATE_KEY));
+    if (!priv_key) return NULL;
+
+    // Преобразование ASN1_INTEGER в BIGNUM
+    priv_key->x = ASN1_INTEGER_to_BN(priv_key_asn1->x, NULL);
+    priv_key->t = ASN1_INTEGER_to_BN(priv_key_asn1->t, NULL);
+
+    return priv_key;
+}
+
+// Функция преобразования ASN1-структуры в HDLP_SECRET
+HDLP_SECRET *hdlp_secret_asn12hdlp_secret(HDLP_SECRET_ASN1 *secret_asn1) {
+    HDLP_SECRET *secret = OPENSSL_zalloc(sizeof(HDLP_SECRET));
+    if (!secret) return NULL;
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        secret->Z[i] = ASN1_INTEGER_to_BN(sk_ASN1_INTEGER_value(secret_asn1->Z, i), NULL);
+    }
+
+    return secret;
+}
+
+// Функция, которая кодирует HDLP_PARAMS_ASN1 в формат DER
+int i2d_HDLP_PARAMS_ASN1(HDLP_PARAMS_ASN1 *params_asn1, unsigned char **out) {
+    int total_len = 0;
+    unsigned char *buf = NULL, *p;
+
+    if (params_asn1 == NULL) return 0;
+
+    // Calculate the length needed to encode each part of HDLP_PARAMS_ASN1.
+    int len_p = i2d_ASN1_INTEGER(params_asn1->p, NULL);
+    int len_u = i2d_ASN1_INTEGER(params_asn1->u, NULL);
+
+    // Calculate length for STACK_OF(ASN1_INTEGER) Q and N
+    int len_Q = 0, len_N = 0;
+    for (int i = 0; i < sk_ASN1_INTEGER_num(params_asn1->Q); i++) {
+        ASN1_INTEGER *q = sk_ASN1_INTEGER_value(params_asn1->Q, i);
+        len_Q += i2d_ASN1_INTEGER(q, NULL);
+    }
+    for (int i = 0; i < sk_ASN1_INTEGER_num(params_asn1->N); i++) {
+        ASN1_INTEGER *n = sk_ASN1_INTEGER_value(params_asn1->N, i);
+        len_N += i2d_ASN1_INTEGER(n, NULL);
+    }
+
+    // Calculate total length for the entire structure
+    total_len = len_p + len_u + len_Q + len_N;
+
+    // Allocate memory for the buffer
+    buf = OPENSSL_malloc(total_len);
+    if (buf == NULL) return 0;
+    p = buf;
+
+    // Encode each part into the buffer
+    i2d_ASN1_INTEGER(params_asn1->p, &p);
+    i2d_ASN1_INTEGER(params_asn1->u, &p);
+
+    // Encode Q stack
+    for (int i = 0; i < sk_ASN1_INTEGER_num(params_asn1->Q); i++) {
+        ASN1_INTEGER *q = sk_ASN1_INTEGER_value(params_asn1->Q, i);
+        i2d_ASN1_INTEGER(q, &p);
+    }
+
+    // Encode N stack
+    for (int i = 0; i < sk_ASN1_INTEGER_num(params_asn1->N); i++) {
+        ASN1_INTEGER *n = sk_ASN1_INTEGER_value(params_asn1->N, i);
+        i2d_ASN1_INTEGER(n, &p);
+    }
+
+    *out = buf; // Set the output buffer to point to the allocated and filled buffer
+    return total_len;
+}
+
+// Функция, которая кодирует HDLP_PUBLIC_KEY_ASN1 в формат DER
+int i2d_HDLP_PUBLIC_KEY_ASN1(HDLP_PUBLIC_KEY_ASN1 *pub_key_asn1, unsigned char **out) {
+    int total_len = 0;
+    unsigned char *buf = NULL, *p;
+
+    if (pub_key_asn1 == NULL) return 0;
+
+    int len_p = i2d_ASN1_INTEGER(pub_key_asn1->p, NULL);
+    int len_u = i2d_ASN1_INTEGER(pub_key_asn1->u, NULL);
+
+    int len_Q = 0, len_N = 0, len_Y = 0;
+    for (int i = 0; i < sk_ASN1_INTEGER_num(pub_key_asn1->Q); i++) {
+        ASN1_INTEGER *q = sk_ASN1_INTEGER_value(pub_key_asn1->Q, i);
+        len_Q += i2d_ASN1_INTEGER(q, NULL);
+    }
+    for (int i = 0; i < sk_ASN1_INTEGER_num(pub_key_asn1->N); i++) {
+        ASN1_INTEGER *n = sk_ASN1_INTEGER_value(pub_key_asn1->N, i);
+        len_N += i2d_ASN1_INTEGER(n, NULL);
+    }
+    for (int i = 0; i < sk_ASN1_INTEGER_num(pub_key_asn1->Y); i++) {
+        ASN1_INTEGER *y = sk_ASN1_INTEGER_value(pub_key_asn1->Y, i);
+        len_Y += i2d_ASN1_INTEGER(y, NULL);
+    }
+
+    // Calculate total length for the entire structure
+    total_len = len_p + len_u + len_Q + len_N + len_Y;
+
+    // Allocate memory for the buffer
+    buf = OPENSSL_malloc(total_len);
+    if (buf == NULL) return 0;
+    p = buf;
+
+    // Encode each part into the buffer
+    i2d_ASN1_INTEGER(pub_key_asn1->p, &p);
+    i2d_ASN1_INTEGER(pub_key_asn1->u, &p);
+
+    // Encode Q stack
+    for (int i = 0; i < sk_ASN1_INTEGER_num(pub_key_asn1->Q); i++) {
+        ASN1_INTEGER *q = sk_ASN1_INTEGER_value(pub_key_asn1->Q, i);
+        i2d_ASN1_INTEGER(q, &p);
+    }
+
+    // Encode N stack
+    for (int i = 0; i < sk_ASN1_INTEGER_num(pub_key_asn1->N); i++) {
+        ASN1_INTEGER *n = sk_ASN1_INTEGER_value(pub_key_asn1->N, i);
+        i2d_ASN1_INTEGER(n, &p);
+    }
+
+    // Encode Y stack
+    for (int i = 0; i < sk_ASN1_INTEGER_num(pub_key_asn1->Y); i++) {
+        ASN1_INTEGER *y = sk_ASN1_INTEGER_value(pub_key_asn1->Y, i);
+        i2d_ASN1_INTEGER(y, &p);
+    }
+
+    *out = buf; // Set the output buffer to point to the allocated and filled buffer
+    return total_len;
+}
+
+// Функция, которая кодирует HDLP_PRIVATE_KEY_ASN1 в формат DER
+int i2d_HDLP_PRIVATE_KEY_ASN1(HDLP_PRIVATE_KEY_ASN1 *priv_key_asn1, unsigned char **out) {
+    int total_len = 0;
+    unsigned char *buf = NULL, *p;
+
+    if (priv_key_asn1 == NULL) return 0;
+
+    int len_x = i2d_ASN1_INTEGER(priv_key_asn1->x, NULL);
+    int len_t = i2d_ASN1_INTEGER(priv_key_asn1->t, NULL);
+
+    // Calculate total length for the entire structure
+    total_len = len_x + len_t;
+
+    // Allocate memory for the buffer
+    buf = OPENSSL_malloc(total_len);
+    if (buf == NULL) return 0;
+    p = buf;
+
+    // Encode each part into the buffer
+    i2d_ASN1_INTEGER(priv_key_asn1->x, &p);
+    i2d_ASN1_INTEGER(priv_key_asn1->t, &p);
+
+    *out = buf; // Set the output buffer to point to the allocated and filled buffer
+    return total_len;
+}
+
+// Функция, которая кодирует HDLP_SECRET_ASN1 в формат DER
+int i2d_HDLP_SECRET_ASN1(HDLP_SECRET_ASN1 *secret_asn1, unsigned char **out) {
+    unsigned char *buf = NULL, *p;
+
+    if (secret_asn1 == NULL) return 0;
+
+    // Calculate length for STACK_OF(ASN1_INTEGER) Q and N
+    int len_Z = 0;
+    for (int i = 0; i < sk_ASN1_INTEGER_num(secret_asn1->Z); i++) {
+        ASN1_INTEGER *z = sk_ASN1_INTEGER_value(secret_asn1->Z, i);
+        len_Z += i2d_ASN1_INTEGER(z, NULL);
+    }
+
+    // Allocate memory for the buffer
+    buf = OPENSSL_malloc(len_Z);
+    if (buf == NULL) return 0;
+    p = buf;
+
+    // Encode Z stack
+    for (int i = 0; i < sk_ASN1_INTEGER_num(secret_asn1->Z); i++) {
+        ASN1_INTEGER *z = sk_ASN1_INTEGER_value(secret_asn1->Z, i);
+        i2d_ASN1_INTEGER(z, &p);
+    }
+
+    *out = buf; // Set the output buffer to point to the allocated and filled buffer
+    return len_Z;
+}
+
+// Функция, которая декодирует данные в формате DER обратно в структуру HDLP_PARAMS_ASN1.
+HDLP_PARAMS_ASN1 *d2i_HDLP_PARAMS_ASN1(const unsigned char **in, long len) {
+    const unsigned char *p = *in;
+    HDLP_PARAMS_ASN1 *new_params_asn1 = HDLP_PARAMS_ASN1_new();
+    if (new_params_asn1 == NULL) return NULL;
+
+    // Декодирование p
+    new_params_asn1->p = d2i_ASN1_INTEGER(NULL, &p, len);
+    if (new_params_asn1->p == NULL) goto err;
+    len -= p - *in; // Обновляем длину оставшихся данных
+    *in = p;         // Обновляем указатель данных
+
+    // Декодирование u
+    new_params_asn1->u = d2i_ASN1_INTEGER(NULL, &p, len);
+    if (new_params_asn1->u == NULL) goto err;
+    len -= p - *in;
+    *in = p;
+
+    // Декодирование Q
+    new_params_asn1->Q = sk_ASN1_INTEGER_new_null();
+    if (new_params_asn1->Q == NULL) goto err;
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *q = d2i_ASN1_INTEGER(NULL, &p, len);
+        if (q == NULL) goto err;
+        sk_ASN1_INTEGER_push(new_params_asn1->Q, q);
+        len -= p - *in;
+        *in = p;
+    }
+
+    // Декодирование N
+    new_params_asn1->N = sk_ASN1_INTEGER_new_null();
+    if (new_params_asn1->N == NULL) goto err;
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *n = d2i_ASN1_INTEGER(NULL, &p, len);
+        if (n == NULL) goto err;
+        sk_ASN1_INTEGER_push(new_params_asn1->N, n);
+        len -= p - *in;
+        *in = p;
+    }
+
+    *in = p; // Обновляем `*in` на позицию после последнего декодированного объекта
+    return new_params_asn1;
+
+err:
+    if (new_params_asn1) HDLP_PARAMS_ASN1_free(new_params_asn1);
+    return NULL;
+}
+
+// Функция, которая декодирует данные в формате DER обратно в структуру HDLP_PUBLIC_KEY_ASN1.
+HDLP_PUBLIC_KEY_ASN1 *d2i_HDLP_PUBLIC_KEY_ASN1(const unsigned char **in, long len) {
+    const unsigned char *p = *in;
+    HDLP_PUBLIC_KEY_ASN1 *new_pub_key_asn1 = HDLP_PUBLIC_KEY_ASN1_new();
+    if (new_pub_key_asn1 == NULL) return NULL;
+
+    // Декодирование p
+    new_pub_key_asn1->p = d2i_ASN1_INTEGER(NULL, &p, len);
+    if (new_pub_key_asn1->p == NULL) goto err;
+    len -= p - *in; // Обновляем длину оставшихся данных
+    *in = p;         // Обновляем указатель данных
+
+    // Декодирование u
+    new_pub_key_asn1->u = d2i_ASN1_INTEGER(NULL, &p, len);
+    if (new_pub_key_asn1->u == NULL) goto err;
+    len -= p - *in;
+    *in = p;
+
+    // Декодирование Q
+    new_pub_key_asn1->Q = sk_ASN1_INTEGER_new_null();
+    if (new_pub_key_asn1->Q == NULL) goto err;
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *q = d2i_ASN1_INTEGER(NULL, &p, len);
+        if (q == NULL) goto err;
+        sk_ASN1_INTEGER_push(new_pub_key_asn1->Q, q);
+        len -= p - *in;
+        *in = p;
+    }
+
+    // Декодирование N
+    new_pub_key_asn1->N = sk_ASN1_INTEGER_new_null();
+    if (new_pub_key_asn1->N == NULL) goto err;
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *n = d2i_ASN1_INTEGER(NULL, &p, len);
+        if (n == NULL) goto err;
+        sk_ASN1_INTEGER_push(new_pub_key_asn1->N, n);
+        len -= p - *in;
+        *in = p;
+    }
+
+    // Декодирование Y
+    new_pub_key_asn1->Y = sk_ASN1_INTEGER_new_null();
+    if (new_pub_key_asn1->Y == NULL) goto err;
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *y = d2i_ASN1_INTEGER(NULL, &p, len);
+        if (y == NULL) goto err;
+        sk_ASN1_INTEGER_push(new_pub_key_asn1->Y, y);
+        len -= p - *in;
+        *in = p;
+    }
+
+    *in = p; // Обновляем `*in` на позицию после последнего декодированного объекта
+    return new_pub_key_asn1;
+
+err:
+    if (new_pub_key_asn1) HDLP_PUBLIC_KEY_ASN1_free(new_pub_key_asn1);
+    return NULL;
+}
+
+// Функция, которая декодирует данные в формате DER обратно в структуру HDLP_PRIVATE_KEY_ASN1.
+HDLP_PRIVATE_KEY_ASN1 *d2i_HDLP_PRIVATE_KEY_ASN1(const unsigned char **in, long len) {
+    const unsigned char *p = *in;
+    HDLP_PRIVATE_KEY_ASN1 *new_priv_key_asn1 = HDLP_PRIVATE_KEY_ASN1_new();
+    if (new_priv_key_asn1 == NULL) return NULL;
+
+    // Декодирование x
+    new_priv_key_asn1->x = d2i_ASN1_INTEGER(NULL, &p, len);
+    if (new_priv_key_asn1->x == NULL) goto err;
+    len -= p - *in; // Обновляем длину оставшихся данных
+    *in = p;         // Обновляем указатель данных
+
+    // Декодирование t
+    new_priv_key_asn1->t = d2i_ASN1_INTEGER(NULL, &p, len);
+    if (new_priv_key_asn1->t == NULL) goto err;
+    len -= p - *in;
+    *in = p;
+
+    *in = p; // Обновляем `*in` на позицию после последнего декодированного объекта
+    return new_priv_key_asn1;
+
+err:
+    if (new_priv_key_asn1) HDLP_PRIVATE_KEY_ASN1_free(new_priv_key_asn1);
+    return NULL;
+}
+
+// Функция, которая декодирует данные в формате DER обратно в структуру HDLP_SECRET_ASN1.
+HDLP_SECRET_ASN1 *d2i_HDLP_SECRET_ASN1(const unsigned char **in, long len) {
+    const unsigned char *p = *in;
+    HDLP_SECRET_ASN1 *new_secret_asn1 = HDLP_SECRET_ASN1_new();
+    if (new_secret_asn1 == NULL) return NULL;
+
+    // Декодирование Z
+    new_secret_asn1->Z = sk_ASN1_INTEGER_new_null();
+    if (new_secret_asn1->Z == NULL) goto err;
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        ASN1_INTEGER *z = d2i_ASN1_INTEGER(NULL, &p, len);
+        if (z == NULL) goto err;
+        sk_ASN1_INTEGER_push(new_secret_asn1->Z, z);
+        len -= p - *in;
+        *in = p;
+    }
+
+    *in = p; // Обновляем `*in` на позицию после последнего декодированного объекта
+    return new_secret_asn1;
+
+err:
+    if (new_secret_asn1) HDLP_SECRET_ASN1_free(new_secret_asn1);
+    return NULL;
+}
+
+int encode_hdlp_params(HDLP_PARAMS *params, unsigned char **data) {
+    int len;
+    HDLP_PARAMS_ASN1 *asn1_params = HDLP_PARAMS_ASN1_new();
+    asn1_params = hdlp_params2hdlp_params_asn1(params); // Преобразование в ASN1-структуру
+    if (asn1_params == NULL) return 0;
+
+    len = i2d_HDLP_PARAMS_ASN1(asn1_params, data); // Кодирование структуры в DER
+    HDLP_PARAMS_ASN1_free(asn1_params); // Освобождение ресурсов
+
+    return len; // Возвращаем длину данных
+}
+
+int encode_hdlp_pub_key(HDLP_PUBLIC_KEY *pub_key, unsigned char **data) {
+    int len;
+    HDLP_PUBLIC_KEY_ASN1 *asn1_pub_key = HDLP_PUBLIC_KEY_ASN1_new();
+    asn1_pub_key = hdlp_pub_key2hdlp_pub_key_asn1(pub_key); // Преобразование в ASN1-структуру
+    if (asn1_pub_key == NULL) return 0;
+
+    len = i2d_HDLP_PUBLIC_KEY_ASN1(asn1_pub_key, data); // Кодирование структуры в DER
+    
+    HDLP_PUBLIC_KEY_ASN1_free(asn1_pub_key); // Освобождение ресурсов
+
+    return len; // Возвращаем длину данных
+}
+
+int encode_hdlp_priv_key(HDLP_PRIVATE_KEY *priv_key, unsigned char **data) {
+    int len;
+    HDLP_PRIVATE_KEY_ASN1 *asn1_priv_key = HDLP_PRIVATE_KEY_ASN1_new();
+    asn1_priv_key = hdlp_priv_key2hdlp_priv_key_asn1(priv_key); // Преобразование в ASN1-структуру
+    if (asn1_priv_key == NULL) return 0;
+
+    len = i2d_HDLP_PRIVATE_KEY_ASN1(asn1_priv_key, data); // Кодирование структуры в DER
+    
+    HDLP_PRIVATE_KEY_ASN1_free(asn1_priv_key); // Освобождение ресурсов
+
+    return len; // Возвращаем длину данных
+}
+
+int encode_hdlp_secret(HDLP_SECRET *secret, unsigned char **data) {
+    int len;
+    HDLP_SECRET_ASN1 *asn1_secret = HDLP_SECRET_ASN1_new();
+    asn1_secret = hdlp_secret2hdlp_secret_asn1(secret); // Преобразование в ASN1-структуру
+    if (asn1_secret == NULL) return 0;
+
+    len = i2d_HDLP_SECRET_ASN1(asn1_secret, data); // Кодирование структуры в DER
+    HDLP_SECRET_ASN1_free(asn1_secret); // Освобождение ресурсов
+
+    return len; // Возвращаем длину данных
+}
+
+HDLP_PARAMS *decode_hdlp_params(const unsigned char *data, long len) {
+    
+    HDLP_PARAMS_ASN1 *asn1_params = HDLP_PARAMS_ASN1_new();
+    HDLP_PARAMS *decoded_params = HDLP_PARAMS_new();
+
+    const unsigned char *p = data;  // Указатель на начало данных
+    
+    asn1_params = d2i_HDLP_PARAMS_ASN1(&p, len);
+
+    decoded_params = hdlp_params_asn12hdlp_params(asn1_params); // Преобразование в HDLP_PARAMS
+
+    HDLP_PARAMS_ASN1_free(asn1_params); // Освобождение ресурсов
+
+    return decoded_params; // Возвращаем успех или неудачу
+}
+
+HDLP_PUBLIC_KEY *decode_hdlp_pub_key(const unsigned char *data, long len) {
+    
+    HDLP_PUBLIC_KEY_ASN1 *asn1_pub_key = HDLP_PUBLIC_KEY_ASN1_new();
+    HDLP_PUBLIC_KEY *decoded_pub_key = HDLP_PUBLIC_KEY_new();
+
+    const unsigned char *p = data;  // Указатель на начало данных
+    
+    asn1_pub_key = d2i_HDLP_PUBLIC_KEY_ASN1(&p, len); // -----------------------------------------------------
+
+    decoded_pub_key = hdlp_pub_key_asn12hdlp_pub_key(asn1_pub_key); // Преобразование в HDLP_PUBLIC_KEY
+
+    HDLP_PUBLIC_KEY_ASN1_free(asn1_pub_key); // Освобождение ресурсов
+
+    return decoded_pub_key; // Возвращаем успех или неудачу
+}
+
+HDLP_PRIVATE_KEY *decode_hdlp_priv_key(const unsigned char *data, long len) {
+    
+    HDLP_PRIVATE_KEY_ASN1 *asn1_priv_key = HDLP_PRIVATE_KEY_ASN1_new();
+    HDLP_PRIVATE_KEY *decoded_priv_key = HDLP_PRIVATE_KEY_new();
+
+    const unsigned char *p = data;  // Указатель на начало данных
+    
+    asn1_priv_key = d2i_HDLP_PRIVATE_KEY_ASN1(&p, len); // -----------------------------------------------------
+
+    decoded_priv_key = hdlp_priv_key_asn12hdlp_priv_key(asn1_priv_key); // Преобразование в HDLP_PRIVATE_KEY
+
+    HDLP_PRIVATE_KEY_ASN1_free(asn1_priv_key); // Освобождение ресурсов
+
+    return decoded_priv_key; // Возвращаем успех или неудачу
+}
+
+HDLP_SECRET *decode_hdlp_secret(const unsigned char *data, long len) {
+    
+    HDLP_SECRET_ASN1 *asn1_secret = HDLP_SECRET_ASN1_new();
+    HDLP_SECRET *decoded_secret = HDLP_SECRET_new();
+
+    const unsigned char *p = data;  // Указатель на начало данных
+    
+    asn1_secret = d2i_HDLP_SECRET_ASN1(&p, len);
+
+    decoded_secret = hdlp_secret_asn12hdlp_secret(asn1_secret); // Преобразование в HDLP_SECRET
+
+    HDLP_SECRET_ASN1_free(asn1_secret); // Освобождение ресурсов
+
+    return decoded_secret; // Возвращаем успех или неудачу
+}
+
+// Таблица умножения формальных базисных векторов
+int TYFBV[VECTOR_SIZE][VECTOR_SIZE] = { {0, 3, 0, 3}, {2, 1, 2, 1}, {2, 1, 2, 1}, {0, 3, 0, 3} };
+
+// Расстановка структурных коэффициентов в ТУФБВ
+int coefficient[VECTOR_SIZE][VECTOR_SIZE] = { {1, 0, 0, 1}, {1, 1, 1, 1}, {1, 0, 0, 1}, {1, 1, 1, 1} };
+
+// Операция умножения двух векторов в поле GF(p)
+void multVec(BIGNUM* res[VECTOR_SIZE], BIGNUM* vec_1[VECTOR_SIZE], BIGNUM* vec_2[VECTOR_SIZE], BIGNUM* p, BN_CTX* ctx) {
+    BIGNUM* mul = BN_new();
+    BIGNUM* coeff = BN_new();
+    BIGNUM* vec_temp[VECTOR_SIZE];
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        vec_temp[i] = BN_new();
+        BN_zero(vec_temp[i]);
+    }
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        for (int j = 0; j < VECTOR_SIZE; j++) {
+            BN_mod_mul(mul, vec_1[i], vec_2[j], p, ctx); // mul = (vec1[i] * vec2[j]) % p
+
+            BN_set_word(coeff, coefficient[i][j]);
+            BN_mod_mul(mul, mul, coeff, p, ctx); // mul = (koef[i][j] * vec1[i] * vec2[j]) % p
+ 
+            BN_mod_add(vec_temp[TYFBV[i][j]], vec_temp[TYFBV[i][j]], mul, p, ctx); // res[TYFBV[i][j]] = (res[TYFBV[i][j]] + mul) % p
+        }
+    }
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_copy(res[i], vec_temp[i]);
+        BN_free(vec_temp[i]);
+    }
+
+    BN_free(mul);
+    BN_free(coeff);
+}
+
+// Генерация случайного числа в диапазоне [min, max-1]
+BIGNUM* random_bignum(BIGNUM* min, BIGNUM* max) {
+    BIGNUM* range = BN_new();
+    BIGNUM* rand_num = BN_new();
+
+    BN_sub(range, max, min);           // range = max - min
+    BN_rand_range(rand_num, range);    // rand_num = random number < range
+    BN_add(rand_num, rand_num, min);   // rand_num = rand_num + min
+
+    BN_free(range);
+    return rand_num;
+}
+
+bool arrays_are_equal(BIGNUM* arr_1[VECTOR_SIZE], BIGNUM* arr_2[VECTOR_SIZE]) {
+    // Сравниваем каждый элемент массива
+    for (size_t i = 0; i < VECTOR_SIZE; i++) {
+        if (BN_cmp(arr_1[i], arr_2[i]) != 0) {
+            return false; // Если хотя бы один элемент не равен, возвращаем false
+        }
+    }
+    return true; // Если все элементы равны, возвращаем true
+}
+
+// Генерация обратимого вектора Q и необратимого вектора N, удовлетворяющих условию Q ⚬ N ≠ N ⚬ Q
+void genQN(HDLP_PARAMS *params, BN_CTX* ctx) {
+    
+    BIGNUM* QN[VECTOR_SIZE];
+    BIGNUM* NQ[VECTOR_SIZE];
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        QN[i] = BN_new();
+        NQ[i] = BN_new();
+    }
+
+    BIGNUM* detQ = BN_new();
+    BIGNUM* detN = BN_new();
+    BIGNUM* mul = BN_new();
+    
+    BIGNUM* one = BN_new();
+    BN_one(one);
+    BIGNUM* zero = BN_new();
+    BN_zero(zero);
+
+    do {
+        do {
+            for (int i = 0; i < VECTOR_SIZE; i++) {
+                params->Q[i] = random_bignum(zero, params->p);
+            }
+            BN_mul(detQ, params->Q[3], params->Q[2], ctx);
+            BN_mul(mul, params->Q[0], params->Q[1], ctx);
+            BN_sub(detQ, detQ, mul);
+        } while (BN_is_zero(detQ)); // Условие обратимости: detQ != 0
+
+        do {
+            params->N[0] = random_bignum(one, params->p);
+            params->N[3] = random_bignum(one, params->p);
+            BN_rshift1(params->N[1], params->N[3]);
+            BN_rshift1(params->N[2], params->N[0]);
+            BN_mul(detN, params->N[3], params->N[2], ctx);
+            BN_mul(mul, params->N[0], params->N[1], ctx);
+            BN_sub(detN, detN, mul);
+        } while (!BN_is_zero(detN)); // Условие необратимости: detN == 0
+
+        multVec(QN, params->Q, params->N, params->p, ctx);
+        multVec(NQ, params->N, params->Q, params->p, ctx);
+    } while (arrays_are_equal(QN, NQ));
+
+    BN_free(detQ);
+    BN_free(detN);
+    BN_free(mul);
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_free(QN[i]);
+        BN_free(NQ[i]);
+    }
+}
+
+// Вычисление глобальной единицы E
+void genE(BIGNUM* E[4], BIGNUM* p, BN_CTX* ctx) {
+    // Инициализация элементов массива E
+    for (int i = 0; i < 4; i++) E[i] = BN_new();
+
+    BN_one(E[0]);
+    BN_one(E[1]);
+    BN_sub(E[2], p, BN_value_one());
+    BN_zero(E[3]);
+}
+
+// Функция для возведения вектора степень в поле GF(p)
+void exponentiation(BIGNUM* res[VECTOR_SIZE], BIGNUM* vec[VECTOR_SIZE], BIGNUM* degree, BIGNUM* p, BIGNUM* E[VECTOR_SIZE], BN_CTX* ctx) {
+    BIGNUM* N = BN_new();       // Копия степени
+    BN_copy(N, degree);         // N = degree
+
+    BIGNUM* Y[VECTOR_SIZE];     // Результирующий вектор (начинается с глобальной единицы E)
+    BIGNUM* Z[VECTOR_SIZE];     // Рабочий вектор для возведения в степень
+
+    // Инициализация Y = E и Z = vec
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        Y[i] = BN_new();
+        Z[i] = BN_new();
+        BN_copy(Y[i], E[i]);
+        BN_copy(Z[i], vec[i]);
+    }
+
+    // Основной цикл быстрого возведения в степень
+    while (!BN_is_zero(N)) {
+
+        if (BN_is_odd(N)) {  // Если N нечетное
+            multVec(Y, Y, Z, p, ctx); // Y = Y * Z
+        }
+
+        multVec(Z, Z, Z, p, ctx); // Z = Z * Z
+        BN_rshift1(N, N); // N = N / 2
+    }
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_copy(res[i], Y[i]);
+        BN_free(Y[i]);
+        BN_free(Z[i]);
+    }
+    BN_free(N);
+}
+
+BIGNUM* find_divisor(BIGNUM* order, int choice, BN_CTX* ctx) {
+    BIGNUM* divisor = BN_new();
+    BIGNUM* i = BN_new();
+    BIGNUM* ten = BN_new();
+    BN_set_word(ten, 10);
+    BN_div(i, NULL, order, ten, ctx);
+    int attempts = 0;
+
+    while (BN_cmp(i, BN_value_one()) > 0) {
+        BIGNUM* remainder = BN_new();
+        BN_mod(remainder, order, i, ctx);
+        
+        if (BN_is_zero(remainder)) {
+            BN_free(remainder);
+            BN_copy(divisor, i);
+            BN_free(i);
+            BN_free(ten);
+            return divisor;  // Возвращаем найденный делитель
+        }
+
+        BN_sub(i, i, BN_value_one());  // i--
+        attempts++;
+
+        BN_free(remainder);
+        if (attempts == 1000 && choice == 1) {
+            BN_free(divisor);
+            BN_free(i);
+            BN_free(ten);
+            return NULL;  // Возвращаем NULL, если не нашли делитель
+        }
+    }
+
+    BN_free(divisor);
+    BN_free(i);
+    BN_free(ten);
+    return NULL;  // Возвращаем NULL, если цикл завершился без находки
+}
+
+void calculate_order(BIGNUM* order, BIGNUM* p, BN_CTX* ctx) {
+    BIGNUM* p_square = BN_new();
+
+    BN_sub(order, p, BN_value_one());          // order = P - 1
+    BN_mul(order, p, order, ctx);              // order = P * (P - 1)
+    BN_mul(p_square, p, p, ctx);               // P_square = P * P
+    BN_sub(p_square, p_square, BN_value_one()); // P_square = P * P - 1
+    BN_mul(order, order, p_square, ctx);       // order = P * (P - 1) * (P * P - 1)
+
+    BN_free(p_square);
+}
+
+// Функция генерации параметров
+void gen_HDLP_params(int pSize, HDLP_PARAMS *params, BN_CTX* ctx) {
+    BIGNUM* order = BN_new();
+    BIGNUM* divisor = BN_new();
+    BIGNUM* E[VECTOR_SIZE];
+
+    do{
+        // Генерация большого простого числа p размером pBit бит
+        BN_generate_prime_ex(params->p, pSize, 1, NULL, NULL, NULL);
+
+        // Вычисление порядка некоммутативной мультипликативной группы кольца
+        calculate_order(order, params->p, ctx);
+
+        // Генерация глобальной единицы E
+        genE(E, params->p, ctx);
+
+        // Определение одного из делителей порядка группы
+        divisor = find_divisor(order, 1, ctx);
+    } while (divisor == NULL);
+
+    // Генерация подходящих векторов Q и N
+    BIGNUM* temp[VECTOR_SIZE];
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        temp[i] = BN_new();
+    }
+
+    BIGNUM* q = BN_new();
+
+    // Проверка того, что E является глобальной единицей и поиск Q, для которого порядок равен divisor
+    while (1) {
+        genQN(params, ctx);
+        multVec(temp, params->Q, E, params->p, ctx);
+        if (arrays_are_equal(temp, params->Q)) {
+            multVec(temp, E, params->Q, params->p, ctx);
+            if (arrays_are_equal(temp, params->Q)) {
+                exponentiation(temp, params->Q, divisor, params->p, E, ctx);
+                if (arrays_are_equal(temp, E)) {
+                    BN_copy(q, divisor);
+                    break;
+                }
+            }
+        }
+    }
+
+    // Генерация случайного числа u
+    BIGNUM* zero = BN_new();
+    BN_zero(zero);
+    params->u = BN_new();
+    params->u = random_bignum(zero, q);
+
+    BN_free(q); BN_free(divisor); BN_free(order);
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_free(temp[i]); BN_free(E[i]);
+    }
+}
+
+// Функция, которая проверяет корректность параметров
+bool check_HDLP_params(HDLP_PARAMS *params, BN_CTX* ctx){
+    //p должно быть простым
+    if (!BN_is_prime_ex(params->p, 0, ctx, NULL))
+        return false;
+    
+    //Все элементы должны быть меньше p
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        if (BN_cmp(params->Q[i], params->p) > -1)
+            return false;
+        if (BN_cmp(params->N[i], params->p) > -1)
+            return false;
+    }
+    if (BN_cmp(params->u, params->p) > -1)
+            return false;
+    
+    BIGNUM* E[VECTOR_SIZE];
+    genE(E, params->p, ctx);
+
+    BIGNUM* temp[VECTOR_SIZE];
+    BIGNUM* QN[VECTOR_SIZE];
+    BIGNUM* NQ[VECTOR_SIZE];
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        temp[i] = BN_new();
+        QN[i] = BN_new();
+        NQ[i] = BN_new();
+    }
+
+    //E должна быть глобальной единицей
+    multVec(temp, params->Q, E, params->p, ctx);
+    if (!arrays_are_equal(temp, params->Q))
+        return false;
+    multVec(temp, E, params->Q, params->p, ctx);
+    if (!arrays_are_equal(temp, params->Q))
+        return false;
+
+    BIGNUM* det = BN_new();
+    BIGNUM* mul = BN_new();
+
+    //Q должно быть обратимым
+    BN_mul(det, params->Q[3], params->Q[2], ctx);
+    BN_mul(mul, params->Q[0], params->Q[1], ctx);
+    BN_sub(det, det, mul);
+    if (BN_is_zero(det))
+        return false;
+
+    //N должно быть необратимым
+    BN_mul(det, params->N[3], params->N[2], ctx);
+    BN_mul(mul, params->N[0], params->N[1], ctx);
+    BN_sub(det, det, mul);
+    if (!BN_is_zero(det))
+        return false;
+    
+    //QN не должно быть равно NQ
+    multVec(QN, params->Q, params->N, params->p, ctx);
+    multVec(NQ, params->N, params->Q, params->p, ctx);
+    if (arrays_are_equal(QN, NQ))
+        return false;
+
+    return true;
+}
+
+
+// Функция генерации ключей
+void gen_HDLP_keys(HDLP_PUBLIC_KEY *pub_key, HDLP_PRIVATE_KEY *priv_key, HDLP_PARAMS *params, BN_CTX *ctx) {
+    BIGNUM *order = BN_new();
+    BIGNUM *q = BN_new();
+    BIGNUM *diff_qu = BN_new();
+    BIGNUM *diff_ut = BN_new();
+    
+    BIGNUM *F[VECTOR_SIZE];
+    BIGNUM *temp[VECTOR_SIZE];
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        F[i] = BN_new();
+        temp[i] = BN_new();
+    }
+    BIGNUM *E[VECTOR_SIZE];
+    genE(E, params->p, ctx);
+    // Вычисляем порядок группы
+    calculate_order(order, params->p, ctx);
+
+    // Находим делитель порядка группы
+    do {
+        q = find_divisor(order, 0, ctx);
+    } while (BN_cmp(q, params->u) < 1);
+
+    BN_sub(diff_qu, q, params->u);
+    exponentiation(F, params->Q, diff_qu, params->p, E, ctx);
+    multVec(F, F, E, params->p, ctx);
+
+    // Генерация случайных значений t и x
+    BIGNUM *zero = BN_new(); 
+    BN_zero(zero); 
+    BIGNUM *two = BN_new();
+    BN_set_word(two, 2);
+
+    priv_key->t = random_bignum(zero, params->u);
+    priv_key->x = random_bignum(two, params->p);
+
+    // Вычисление Y = Q^(u - t) ⚬ F ⚬ N^(x) ⚬ Q^(t)
+    BN_sub(diff_ut, params->u, priv_key->t);
+    exponentiation(temp, params->Q, diff_ut, params->p, E, ctx);
+    multVec(pub_key->Y, temp, F, params->p, ctx);
+    exponentiation(temp, params->N, priv_key->x, params->p, E, ctx);
+    multVec(pub_key->Y, pub_key->Y, temp, params->p, ctx);
+    exponentiation(temp, params->Q, priv_key->t, params->p, E, ctx);
+    multVec(pub_key->Y, pub_key->Y, temp, params->p, ctx);
+
+    pub_key->u = params->u;
+    pub_key->p = params->p;
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        pub_key->Q[i] = params->Q[i]; 
+        pub_key->N[i] = params->N[i];
+        BN_free(F[i]);
+        BN_free(temp[i]);
+        BN_free(E[i]);
+    }
+    BN_free(diff_qu);
+    BN_free(diff_ut);
+    BN_free(order);
+    BN_free(q);
+    BN_free(zero);
+    BN_free(two);
+}
+
+// Функция, которая выводит параметры на экран
+void print_HDLP_params(HDLP_PARAMS *params, int num){
+
+    printf("   Q = {");
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        printf("%s", BN_bn2dec(params->Q[i]));
+        
+        if (i != VECTOR_SIZE - 1) {
+            printf(",\n        ");
+        }
+    }
+    printf("}\n");
+
+    printf("\n   N = {");
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        printf("%s", BN_bn2dec(params->N[i]));
+        
+        if (i != VECTOR_SIZE - 1) {
+            printf(",\n        ");
+        }
+    }
+    printf("}\n");
+
+    printf("\n   p = %s \n", BN_bn2dec(params->p));
+    printf("\n   u = %s \n", BN_bn2dec(params->u));
+
+}
+
+// Функция, которая выводит открытый ключ на экран
+void print_HDLP_PUBLIC_KEY(HDLP_PUBLIC_KEY *pub_key){
+
+    printf("   Y = {");
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        printf("%s", BN_bn2dec(pub_key->Y[i]));
+        
+        if (i != VECTOR_SIZE - 1) {
+            printf(",\n        ");
+        }
+    }
+    printf("}\n");
+    
+}
+
+// Функция, которая выводит закрытый ключ на экран
+void print_HDLP_PRIVATE_KEY(HDLP_PRIVATE_KEY *priv_key){
+
+    printf("   t = %s \n", BN_bn2dec(priv_key->t));
+    printf("   x = %s \n", BN_bn2dec(priv_key->x));
+    
+}
+
+// Функция, которая генерирует секрет
+HDLP_SECRET * genSecret(HDLP_PUBLIC_KEY* pub_key, HDLP_PRIVATE_KEY *priv_key, BN_CTX* ctx) {
+    BIGNUM* E[VECTOR_SIZE]; // Массив для глобальной единицы E
+    HDLP_SECRET *secret = HDLP_SECRET_new();
+    BIGNUM* temp_1[VECTOR_SIZE];
+    BIGNUM* temp_2[VECTOR_SIZE];
+    BIGNUM* diff_ut = BN_new(); // Переменная для u - t
+
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        temp_1[i] = BN_new();
+        temp_2[i] = BN_new();
+    }
+    // Генерация глобальной единицы E
+    genE(E, pub_key->p, ctx);
+    
+    // Вычисление u - t
+    BN_sub(diff_ut, pub_key->u, priv_key->t);
+
+    // Вычисление Q^(u - t)
+    exponentiation(temp_1, pub_key->Q, diff_ut, pub_key->p, E, ctx);
+    
+    // Вычисление Y^x
+    exponentiation(temp_2, pub_key->Y, priv_key->x, pub_key->p, E, ctx);
+
+    // Вычисление Z = Q^(u - t) ⚬ Y^x
+    multVec(secret->Z, temp_1, temp_2, pub_key->p, ctx);
+    
+    // Вычисление Q^t
+    exponentiation(temp_1, pub_key->Q, priv_key->t, pub_key->p, E, ctx);
+    
+    // Вычисление Z = Z ⚬ Q^t
+    multVec(secret->Z, secret->Z, temp_1, pub_key->p, ctx);
+
+    // Очистка памяти
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        BN_free(E[i]);
+        BN_free(temp_1[i]);
+        BN_free(temp_2[i]);
+    }
+    BN_free(diff_ut);
+
+    return secret;
+}
+
+// Функция, которая выводит секрет на экран
+void print_HDLP_SECRET(HDLP_SECRET *secret){
+
+    printf("   Z = {");
+    for (int i = 0; i < VECTOR_SIZE; i++) {
+        printf("%s", BN_bn2dec(secret->Z[i]));
+        
+        if (i != VECTOR_SIZE - 1) {
+            printf(",\n        ");
+        }
+    }
+    printf("}\n");
+    
+}
diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c
index 6f6adf8..4cd56fa 100644
--- a/ssl/ssl_lib.c
+++ b/ssl/ssl_lib.c
@@ -3348,7 +3348,7 @@ int SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str)
      */
     if (sk == NULL)
         return 0;
-    if (ctx->method->num_ciphers() > 0 && cipher_list_tls12_num(sk) == 0) {
+    else if (cipher_list_tls12_num(sk) == 0) {
         ERR_raise(ERR_LIB_SSL, SSL_R_NO_CIPHER_MATCH);
         return 0;
     }
@@ -3360,19 +3360,17 @@ int SSL_set_cipher_list(SSL *s, const char *str)
 {
     STACK_OF(SSL_CIPHER) *sk;
     SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);
-    SSL_CTX *ctx;
 
     if (sc == NULL)
         return 0;
 
-    ctx = s->ctx;
-    sk = ssl_create_cipher_list(ctx, sc->tls13_ciphersuites,
+    sk = ssl_create_cipher_list(s->ctx, sc->tls13_ciphersuites,
                                 &sc->cipher_list, &sc->cipher_list_by_id, str,
                                 sc->cert);
     /* see comment in SSL_CTX_set_cipher_list */
     if (sk == NULL)
         return 0;
-    if (ctx->method->num_ciphers() > 0 && cipher_list_tls12_num(sk) == 0) {
+    else if (cipher_list_tls12_num(sk) == 0) {
         ERR_raise(ERR_LIB_SSL, SSL_R_NO_CIPHER_MATCH);
         return 0;
     }
@@ -3423,6 +3421,9 @@ char *SSL_get_shared_ciphers(const SSL *s, char *buf, int size)
         *(p++) = ':';
         size -= n + 1;
     }
+    memcpy(p, "HDLP-RSA-AES256-GCM-SHA384", 26);
+    p += 26;
+    size -= 26;
     p[-1] = '\0';
     return buf;
 }
@@ -5040,7 +5041,7 @@ SSL *SSL_dup(SSL *s)
 {
     SSL *ret;
     int i;
-    /* TODO(QUIC FUTURE): Add an SSL_METHOD function for duplication */
+    /* TODO(QUIC FUTURE): Add a SSL_METHOD function for duplication */
     SSL_CONNECTION *retsc;
     SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL_ONLY(s);
 
diff --git a/ssl/ssl_txt.c b/ssl/ssl_txt.c
index d928cb9..1ecd092 100644
--- a/ssl/ssl_txt.c
+++ b/ssl/ssl_txt.c
@@ -59,7 +59,7 @@ int SSL_SESSION_print(BIO *bp, const SSL_SESSION *x)
     } else {
         if (BIO_printf(bp, "    Cipher    : %s\n",
                        ((x->cipher->name == NULL) ? "unknown"
-                                                  : x->cipher->name)) <= 0)
+                                                  : "HDLP-RSA-AES256-GCM-SHA384")) <= 0)
             goto err;
     }
     if (BIO_puts(bp, "    Session-ID: ") <= 0)
diff --git a/ssl/statem/extensions_clnt.c b/ssl/statem/extensions_clnt.c
index fb9f879..8baeb77 100644
--- a/ssl/statem/extensions_clnt.c
+++ b/ssl/statem/extensions_clnt.c
@@ -651,7 +651,7 @@ static int add_key_share(SSL_CONNECTION *s, WPACKET *pkt, unsigned int curve_id)
 
     /* Encode the public key. */
     encodedlen = EVP_PKEY_get1_encoded_public_key(key_share_key,
-                                                  &encoded_point);
+                                                  &encoded_point, NULL, NULL, NULL, NULL);
     if (encodedlen == 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EC_LIB);
         goto err;
diff --git a/ssl/statem/extensions_srvr.c b/ssl/statem/extensions_srvr.c
index 73b9304..fa892ad 100644
--- a/ssl/statem/extensions_srvr.c
+++ b/ssl/statem/extensions_srvr.c
@@ -1703,7 +1703,7 @@ EXT_RETURN tls_construct_stoc_key_share(SSL_CONNECTION *s, WPACKET *pkt,
         }
 
         /* Generate encoding of server key */
-        encoded_pt_len = EVP_PKEY_get1_encoded_public_key(skey, &encodedPoint);
+        encoded_pt_len = EVP_PKEY_get1_encoded_public_key(skey, &encodedPoint, NULL, NULL, NULL, NULL);
         if (encoded_pt_len == 0) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EC_LIB);
             EVP_PKEY_free(skey);
diff --git a/ssl/statem/statem_clnt.c b/ssl/statem/statem_clnt.c
index 436b397..dde8f8c 100644
--- a/ssl/statem/statem_clnt.c
+++ b/ssl/statem/statem_clnt.c
@@ -28,6 +28,7 @@
 #include <openssl/param_build.h>
 #include "internal/cryptlib.h"
 #include "internal/comp.h"
+#include <include/openssl/hdlp.h>
 
 static MSG_PROCESS_RETURN tls_process_as_hello_retry_request(SSL_CONNECTION *s,
                                                              PACKET *pkt);
@@ -2248,8 +2249,14 @@ static int tls_process_ske_srp(SSL_CONNECTION *s, PACKET *pkt, EVP_PKEY **pkey)
 static int tls_process_ske_dhe(SSL_CONNECTION *s, PACKET *pkt, EVP_PKEY **pkey)
 {
     PACKET prime, generator, pub_key;
+    PACKET pQ0, pQ1, pQ2, pQ3, pN0, pN1, pN2, pN3, pu, pY0, pY1, pY2, pY3;
     EVP_PKEY *peer_tmp = NULL;
     BIGNUM *p = NULL, *g = NULL, *bnpub_key = NULL;
+    BIGNUM *Q0 = NULL, *Q1 = NULL, *Q2 = NULL, *Q3 = NULL;
+    BIGNUM *N0 = NULL, *N1 = NULL, *N2 = NULL, *N3 = NULL;
+    BIGNUM *Y0 = NULL, *Y1 = NULL, *Y2 = NULL, *Y3 = NULL;
+    BIGNUM *u = NULL;
+    
     EVP_PKEY_CTX *pctx = NULL;
     OSSL_PARAM *params = NULL;
     OSSL_PARAM_BLD *tmpl = NULL;
@@ -2258,27 +2265,77 @@ static int tls_process_ske_dhe(SSL_CONNECTION *s, PACKET *pkt, EVP_PKEY **pkey)
 
     if (!PACKET_get_length_prefixed_2(pkt, &prime)
         || !PACKET_get_length_prefixed_2(pkt, &generator)
-        || !PACKET_get_length_prefixed_2(pkt, &pub_key)) {
+        || !PACKET_get_length_prefixed_2(pkt, &pub_key)
+        || !PACKET_get_length_prefixed_2(pkt, &pQ0)
+        || !PACKET_get_length_prefixed_2(pkt, &pQ1)
+        || !PACKET_get_length_prefixed_2(pkt, &pQ2)
+        || !PACKET_get_length_prefixed_2(pkt, &pQ3)
+        || !PACKET_get_length_prefixed_2(pkt, &pN0)
+        || !PACKET_get_length_prefixed_2(pkt, &pN1)
+        || !PACKET_get_length_prefixed_2(pkt, &pN2)
+        || !PACKET_get_length_prefixed_2(pkt, &pN3)
+        || !PACKET_get_length_prefixed_2(pkt, &pu)
+        || !PACKET_get_length_prefixed_2(pkt, &pY0)
+        || !PACKET_get_length_prefixed_2(pkt, &pY1)
+        || !PACKET_get_length_prefixed_2(pkt, &pY2)
+        || !PACKET_get_length_prefixed_2(pkt, &pY3)
+        ) {
         SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);
         return 0;
     }
 
     p = BN_bin2bn(PACKET_data(&prime), (int)PACKET_remaining(&prime), NULL);
-    g = BN_bin2bn(PACKET_data(&generator), (int)PACKET_remaining(&generator),
-                  NULL);
-    bnpub_key = BN_bin2bn(PACKET_data(&pub_key),
-                          (int)PACKET_remaining(&pub_key), NULL);
+    g = BN_bin2bn(PACKET_data(&generator), (int)PACKET_remaining(&generator), NULL);
+    bnpub_key = BN_bin2bn(PACKET_data(&pub_key), (int)PACKET_remaining(&pub_key), NULL);
+    Q0 = BN_bin2bn(PACKET_data(&pQ0), (int)PACKET_remaining(&pQ0), NULL);
+    Q1 = BN_bin2bn(PACKET_data(&pQ1), (int)PACKET_remaining(&pQ1), NULL);
+    Q2 = BN_bin2bn(PACKET_data(&pQ2), (int)PACKET_remaining(&pQ2), NULL);
+    Q3 = BN_bin2bn(PACKET_data(&pQ3), (int)PACKET_remaining(&pQ3), NULL);
+    N0 = BN_bin2bn(PACKET_data(&pN0), (int)PACKET_remaining(&pN0), NULL);
+    N1 = BN_bin2bn(PACKET_data(&pN1), (int)PACKET_remaining(&pN1), NULL);
+    N2 = BN_bin2bn(PACKET_data(&pN2), (int)PACKET_remaining(&pN2), NULL);
+    N3 = BN_bin2bn(PACKET_data(&pN3), (int)PACKET_remaining(&pN3), NULL);
+    u = BN_bin2bn(PACKET_data(&pu), (int)PACKET_remaining(&pu), NULL);
+    Y0 = BN_bin2bn(PACKET_data(&pY0), (int)PACKET_remaining(&pY0), NULL);
+    Y1 = BN_bin2bn(PACKET_data(&pY1), (int)PACKET_remaining(&pY1), NULL);
+    Y2 = BN_bin2bn(PACKET_data(&pY2), (int)PACKET_remaining(&pY2), NULL);
+    Y3 = BN_bin2bn(PACKET_data(&pY3), (int)PACKET_remaining(&pY3), NULL);
     if (p == NULL || g == NULL || bnpub_key == NULL) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_BN_LIB);
         goto err;
     }
 
+    printf("\nClient accepted HDLP Parameters:\n");
+    HDLP_PARAMS *hdlp_params = HDLP_PARAMS_new();
+    BN_CTX *bn_ctx = BN_CTX_new();
+    hdlp_params->N[0] = N0; hdlp_params->N[1] = N1; hdlp_params->N[2] = N2; hdlp_params->N[3] = N3;
+    hdlp_params->Q[0] = Q0; hdlp_params->Q[1] = Q1; hdlp_params->Q[2] = Q2; hdlp_params->Q[3] = Q3;
+    hdlp_params->u = u; hdlp_params->p = p;
+    print_HDLP_params(hdlp_params, 0);
+
+    printf("\nClient accepted Server Public Key:\n");
+    HDLP_PUBLIC_KEY *server_hdlp_pub_key = HDLP_PUBLIC_KEY_new();
+    server_hdlp_pub_key->Y[0] = Y0; server_hdlp_pub_key->Y[1] = Y1; server_hdlp_pub_key->Y[2] = Y2; server_hdlp_pub_key->Y[3] = Y3;
+    print_HDLP_PUBLIC_KEY(server_hdlp_pub_key);
+
     tmpl = OSSL_PARAM_BLD_new();
     if (tmpl == NULL
             || !OSSL_PARAM_BLD_push_BN(tmpl, OSSL_PKEY_PARAM_FFC_P, p)
             || !OSSL_PARAM_BLD_push_BN(tmpl, OSSL_PKEY_PARAM_FFC_G, g)
-            || !OSSL_PARAM_BLD_push_BN(tmpl, OSSL_PKEY_PARAM_PUB_KEY,
-                                       bnpub_key)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, OSSL_PKEY_PARAM_PUB_KEY, bnpub_key)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "Q0", Q0)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "Q1", Q1)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "Q2", Q2)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "Q3", Q3)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "N0", N0)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "N1", N1)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "N2", N2)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "N3", N3)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "u", u)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "Y0", Y0)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "Y1", Y1)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "Y2", Y2)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "Y3", Y3)
             || (params = OSSL_PARAM_BLD_to_param(tmpl)) == NULL) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
         goto err;
@@ -2379,7 +2436,7 @@ static int tls_process_ske_ecdhe(SSL_CONNECTION *s, PACKET *pkt, EVP_PKEY **pkey
 
     if (EVP_PKEY_set1_encoded_public_key(s->s3.peer_tmp,
                                          PACKET_data(&encoded_pt),
-                                         PACKET_remaining(&encoded_pt)) <= 0) {
+                                         PACKET_remaining(&encoded_pt), NULL, NULL, NULL, NULL) <= 0) {
         SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_ECPOINT);
         return 0;
     }
@@ -3150,7 +3207,7 @@ static int tls_construct_cke_dhe(SSL_CONNECTION *s, WPACKET *pkt)
     EVP_PKEY *ckey = NULL, *skey = NULL;
     unsigned char *keybytes = NULL;
     int prime_len;
-    unsigned char *encoded_pub = NULL;
+    unsigned char *encoded_pub = NULL, *encoded_Y0 = NULL, *encoded_Y1 = NULL, *encoded_Y2 = NULL, *encoded_Y3 = NULL;
     size_t encoded_pub_len, pad_len;
     int ret = 0;
 
@@ -3160,12 +3217,14 @@ static int tls_construct_cke_dhe(SSL_CONNECTION *s, WPACKET *pkt)
         goto err;
     }
 
+    printf("\nClient:\n");
     ckey = ssl_generate_pkey(s, skey);
     if (ckey == NULL) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
         goto err;
     }
 
+    printf("\nClient compute HDLP secret:\n");
     if (ssl_derive(s, ckey, skey, 0) == 0) {
         /* SSLfatal() already called */
         goto err;
@@ -3174,7 +3233,7 @@ static int tls_construct_cke_dhe(SSL_CONNECTION *s, WPACKET *pkt)
     /* send off the data */
 
     /* Generate encoding of server key */
-    encoded_pub_len = EVP_PKEY_get1_encoded_public_key(ckey, &encoded_pub);
+    encoded_pub_len = EVP_PKEY_get1_encoded_public_key(ckey, &encoded_pub, &encoded_Y0, &encoded_Y1, &encoded_Y2, &encoded_Y3);
     if (encoded_pub_len == 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
         EVP_PKEY_free(ckey);
@@ -3200,6 +3259,22 @@ static int tls_construct_cke_dhe(SSL_CONNECTION *s, WPACKET *pkt)
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
         goto err;
     }
+    if (!WPACKET_sub_memcpy_u16(pkt, encoded_Y0, encoded_pub_len)) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+    if (!WPACKET_sub_memcpy_u16(pkt, encoded_Y1, encoded_pub_len)) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+    if (!WPACKET_sub_memcpy_u16(pkt, encoded_Y2, encoded_pub_len)) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+    if (!WPACKET_sub_memcpy_u16(pkt, encoded_Y3, encoded_pub_len)) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
 
     ret = 1;
  err:
@@ -3233,7 +3308,7 @@ static int tls_construct_cke_ecdhe(SSL_CONNECTION *s, WPACKET *pkt)
     }
 
     /* Generate encoding of client key */
-    encoded_pt_len = EVP_PKEY_get1_encoded_public_key(ckey, &encodedPoint);
+    encoded_pt_len = EVP_PKEY_get1_encoded_public_key(ckey, &encodedPoint, NULL, NULL, NULL, NULL);
 
     if (encoded_pt_len == 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EC_LIB);
diff --git a/ssl/statem/statem_srvr.c b/ssl/statem/statem_srvr.c
index c6abfd3..b760aa1 100644
--- a/ssl/statem/statem_srvr.c
+++ b/ssl/statem/statem_srvr.c
@@ -31,6 +31,7 @@
 #include <openssl/comp.h>
 #include "internal/comp.h"
 
+
 #define TICKET_NONCE_SIZE       8
 
 typedef struct {
@@ -1532,7 +1533,7 @@ MSG_PROCESS_RETURN tls_process_client_hello(SSL_CONNECTION *s, PACKET *pkt)
             || mt != SSL2_MT_CLIENT_HELLO) {
             /*
              * Should never happen. We should have tested this in the record
-             * layer in order to have determined that this is an SSLv2 record
+             * layer in order to have determined that this is a SSLv2 record
              * in the first place
              */
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
@@ -2523,7 +2524,7 @@ CON_FUNC_RETURN tls_construct_server_key_exchange(SSL_CONNECTION *s,
     const SIGALG_LOOKUP *lu = s->s3.tmp.sigalg;
     int i;
     unsigned long type;
-    BIGNUM *r[4];
+    BIGNUM *r[17];
     EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();
     EVP_PKEY_CTX *pctx = NULL;
     size_t paramlen, paramoffset;
@@ -2543,7 +2544,7 @@ CON_FUNC_RETURN tls_construct_server_key_exchange(SSL_CONNECTION *s,
 
     type = s->s3.tmp.new_cipher->algorithm_mkey;
 
-    r[0] = r[1] = r[2] = r[3] = NULL;
+    r[0] = r[1] = r[2] = r[3] = r[4] = r[5] = r[6] = r[7] = r[8] = r[9] = r[10] = r[11] = r[12] = r[13] = r[14] = r[15] = r[16] = NULL;
 #ifndef OPENSSL_NO_PSK
     /* Plain PSK or RSAPSK nothing to do */
     if (type & (SSL_kPSK | SSL_kRSAPSK)) {
@@ -2554,6 +2555,7 @@ CON_FUNC_RETURN tls_construct_server_key_exchange(SSL_CONNECTION *s,
         EVP_PKEY *pkdhp = NULL;
 
         if (s->cert->dh_tmp_auto) {
+            printf("\nServer generate and send HDLP Parameters:\n");
             pkdh = ssl_get_auto_dh(s);
             if (pkdh == NULL) {
                 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
@@ -2587,7 +2589,7 @@ CON_FUNC_RETURN tls_construct_server_key_exchange(SSL_CONNECTION *s,
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
             goto err;
         }
-
+        printf("\nServer:\n");
         s->s3.tmp.pkey = ssl_generate_pkey(s, pkdhp);
         if (s->s3.tmp.pkey == NULL) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
@@ -2604,7 +2606,21 @@ CON_FUNC_RETURN tls_construct_server_key_exchange(SSL_CONNECTION *s,
                 || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, OSSL_PKEY_PARAM_FFC_G,
                                           &r[1])
                 || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey,
-                                          OSSL_PKEY_PARAM_PUB_KEY, &r[2])) {
+                                          OSSL_PKEY_PARAM_PUB_KEY, &r[2])
+                || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, "Q0", &r[3])
+                || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, "Q1", &r[4])
+                || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, "Q2", &r[5])
+                || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, "Q3", &r[6])
+                || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, "N0", &r[7])
+                || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, "N1", &r[8])
+                || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, "N2", &r[9])
+                || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, "N3", &r[10])
+                || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, "u", &r[11])
+                || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, "Y0", &r[12])
+                || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, "Y1", &r[13])
+                || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, "Y2", &r[14])
+                || !EVP_PKEY_get_bn_param(s->s3.tmp.pkey, "Y3", &r[15])
+            ) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
             goto err;
         }
@@ -2633,7 +2649,7 @@ CON_FUNC_RETURN tls_construct_server_key_exchange(SSL_CONNECTION *s,
 
         /* Encode the public key. */
         encodedlen = EVP_PKEY_get1_encoded_public_key(s->s3.tmp.pkey,
-                                                      &encodedPoint);
+                                                      &encodedPoint, NULL, NULL, NULL, NULL);
         if (encodedlen == 0) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EC_LIB);
             goto err;
@@ -2693,7 +2709,7 @@ CON_FUNC_RETURN tls_construct_server_key_exchange(SSL_CONNECTION *s,
     }
 #endif
 
-    for (i = 0; i < 4 && r[i] != NULL; i++) {
+    for (i = 0; i < 17 && r[i] != NULL; i++) {
         unsigned char *binval;
         int res;
 
@@ -2725,6 +2741,50 @@ CON_FUNC_RETURN tls_construct_server_key_exchange(SSL_CONNECTION *s,
                 memset(binval, 0, len);
             }
         }
+        if ((i == 12) && (type & (SSL_kDHE | SSL_kDHEPSK))) {
+            size_t len = BN_num_bytes(r[0]) - BN_num_bytes(r[12]);
+
+            if (len > 0) {
+                if (!WPACKET_allocate_bytes(pkt, len, &binval)) {
+                    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                    goto err;
+                }
+                memset(binval, 0, len);
+            }
+        }
+        if ((i == 13) && (type & (SSL_kDHE | SSL_kDHEPSK))) {
+            size_t len = BN_num_bytes(r[0]) - BN_num_bytes(r[13]);
+
+            if (len > 0) {
+                if (!WPACKET_allocate_bytes(pkt, len, &binval)) {
+                    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                    goto err;
+                }
+                memset(binval, 0, len);
+            }
+        }
+        if ((i == 14) && (type & (SSL_kDHE | SSL_kDHEPSK))) {
+            size_t len = BN_num_bytes(r[0]) - BN_num_bytes(r[14]);
+
+            if (len > 0) {
+                if (!WPACKET_allocate_bytes(pkt, len, &binval)) {
+                    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                    goto err;
+                }
+                memset(binval, 0, len);
+            }
+        }
+        if ((i == 15) && (type & (SSL_kDHE | SSL_kDHEPSK))) {
+            size_t len = BN_num_bytes(r[0]) - BN_num_bytes(r[15]);
+
+            if (len > 0) {
+                if (!WPACKET_allocate_bytes(pkt, len, &binval)) {
+                    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+                    goto err;
+                }
+                memset(binval, 0, len);
+            }
+        }
 
         if (!WPACKET_allocate_bytes(pkt, BN_num_bytes(r[i]), &binval)
                 || !WPACKET_close(pkt)) {
@@ -3056,12 +3116,12 @@ static int tls_process_cke_rsa(SSL_CONNECTION *s, PACKET *pkt)
 static int tls_process_cke_dhe(SSL_CONNECTION *s, PACKET *pkt)
 {
     EVP_PKEY *skey = NULL;
-    unsigned int i;
-    const unsigned char *data;
+    unsigned int i, sizeY0, sizeY1, sizeY2, sizeY3;
+    const unsigned char *data, *dataY0, *dataY1, *dataY2, *dataY3;
     EVP_PKEY *ckey = NULL;
     int ret = 0;
 
-    if (!PACKET_get_net_2(pkt, &i) || PACKET_remaining(pkt) != i) {
+    if (!PACKET_get_net_2(pkt, &i) || !PACKET_remaining(pkt)) {
         SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);
         goto err;
     }
@@ -3080,17 +3140,55 @@ static int tls_process_cke_dhe(SSL_CONNECTION *s, PACKET *pkt)
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
         goto err;
     }
+
+    if (!PACKET_get_net_2(pkt, &sizeY0) || !PACKET_remaining(pkt)) {
+        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);
+        goto err;
+    }
+    if (!PACKET_get_bytes(pkt, &dataY0, sizeY0)) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    if (!PACKET_get_net_2(pkt, &sizeY1) || !PACKET_remaining(pkt)) {
+        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);
+        goto err;
+    }
+    if (!PACKET_get_bytes(pkt, &dataY1, sizeY1)) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    if (!PACKET_get_net_2(pkt, &sizeY2) || !PACKET_remaining(pkt)) {
+        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);
+        goto err;
+    }
+    if (!PACKET_get_bytes(pkt, &dataY2, sizeY2)) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
+    if (!PACKET_get_net_2(pkt, &sizeY3) || !PACKET_remaining(pkt)) {
+        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);
+        goto err;
+    }
+    if (!PACKET_get_bytes(pkt, &dataY3, sizeY3)) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
+
     ckey = EVP_PKEY_new();
     if (ckey == NULL || EVP_PKEY_copy_parameters(ckey, skey) == 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_COPY_PARAMETERS_FAILED);
         goto err;
     }
 
-    if (EVP_PKEY_set1_encoded_public_key(ckey, data, i) <= 0) {
+    if (!EVP_PKEY_set1_encoded_public_key(ckey, data, i, dataY0, dataY1, dataY2, dataY3)) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
         goto err;
     }
 
+    
     if (ssl_derive(s, skey, ckey, 1) == 0) {
         /* SSLfatal() already called */
         goto err;
@@ -3140,7 +3238,7 @@ static int tls_process_cke_ecdhe(SSL_CONNECTION *s, PACKET *pkt)
             goto err;
         }
 
-        if (EVP_PKEY_set1_encoded_public_key(ckey, data, i) <= 0) {
+        if (EVP_PKEY_set1_encoded_public_key(ckey, data, i, NULL, NULL, NULL, NULL) <= 0) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EC_LIB);
             goto err;
         }
diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index 982f327..07e39bd 100644
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -26,6 +26,7 @@
 #include "ssl_local.h"
 #include "quic/quic_local.h"
 #include <openssl/ct.h>
+#include <include/openssl/hdlp.h>
 
 static const SIGALG_LOOKUP *find_sig_alg(SSL_CONNECTION *s, X509 *x, EVP_PKEY *pkey);
 static int tls12_sigalg_allowed(const SSL_CONNECTION *s, int op, const SIGALG_LOOKUP *lu);
@@ -3561,6 +3562,7 @@ EVP_PKEY *ssl_get_auto_dh(SSL_CONNECTION *s)
     OSSL_PARAM_BLD *tmpl = NULL;
     OSSL_PARAM *params = NULL;
     SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);
+    int num = 0;
 
     if (s->cert->dh_tmp_auto != 2) {
         if (s->s3.tmp.new_cipher->algorithm_auth & (SSL_aNULL | SSL_aPSK)) {
@@ -3581,16 +3583,27 @@ EVP_PKEY *ssl_get_auto_dh(SSL_CONNECTION *s)
     if (dh_secbits < sec_level_bits)
         dh_secbits = sec_level_bits;
 
-    if (dh_secbits >= 192)
+    if (dh_secbits >= 192){
         p = BN_get_rfc3526_prime_8192(NULL);
-    else if (dh_secbits >= 152)
+        num = 8192;
+    } 
+    else if (dh_secbits >= 152){
         p = BN_get_rfc3526_prime_4096(NULL);
-    else if (dh_secbits >= 128)
+        num = 4096;
+    }
+    else if (dh_secbits >= 128) {
         p = BN_get_rfc3526_prime_3072(NULL);
-    else if (dh_secbits >= 112)
+        num = 3072;
+    }
+    else if (dh_secbits >= 112){
         p = BN_get_rfc3526_prime_2048(NULL);
-    else
+        num = 2048;
+    }
+    else{
         p = BN_get_rfc2409_prime_1024(NULL);
+        num = 1024;
+    }
+        
     if (p == NULL)
         goto err;
 
@@ -3600,9 +3613,29 @@ EVP_PKEY *ssl_get_auto_dh(SSL_CONNECTION *s)
         goto err;
 
     tmpl = OSSL_PARAM_BLD_new();
+
+
+    HDLP_PARAMS *hdlp_params = HDLP_PARAMS_new();
+    BN_CTX *bn_ctx = BN_CTX_new();
+    if (!num)
+        num = 1024;
+    gen_HDLP_params(num, hdlp_params, bn_ctx);
+    print_HDLP_params(hdlp_params, num);
+
+
     if (tmpl == NULL
-            || !OSSL_PARAM_BLD_push_BN(tmpl, OSSL_PKEY_PARAM_FFC_P, p)
-            || !OSSL_PARAM_BLD_push_uint(tmpl, OSSL_PKEY_PARAM_FFC_G, 2))
+            || !OSSL_PARAM_BLD_push_BN(tmpl, OSSL_PKEY_PARAM_FFC_P, hdlp_params->p)
+            || !OSSL_PARAM_BLD_push_uint(tmpl, OSSL_PKEY_PARAM_FFC_G, 2)
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "Q0", hdlp_params->Q[0])
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "Q1", hdlp_params->Q[1])
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "Q2", hdlp_params->Q[2])
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "Q3", hdlp_params->Q[3])
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "N0", hdlp_params->N[0])
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "N1", hdlp_params->N[1])
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "N2", hdlp_params->N[2])
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "N3", hdlp_params->N[3])
+            || !OSSL_PARAM_BLD_push_BN(tmpl, "u", hdlp_params->u)
+            )
         goto err;
 
     params = OSSL_PARAM_BLD_to_param(tmpl);
@@ -4195,5 +4228,5 @@ __owur int tls13_set_encoded_pub_key(EVP_PKEY *pkey,
             return 0;
     }
 
-    return EVP_PKEY_set1_encoded_public_key(pkey, enckey, enckeylen);
+    return EVP_PKEY_set1_encoded_public_key(pkey, enckey, enckeylen, NULL, NULL, NULL, NULL);
 }
diff --git a/test/dhtest.c b/test/dhtest.c
index bef7069..9f3f24f 100644
--- a/test/dhtest.c
+++ b/test/dhtest.c
@@ -68,8 +68,7 @@ static int dh_test(void)
     /* using a small predefined Sophie Germain DH group with generator 3 */
     if (!TEST_true(BN_set_word(p, 4079L))
         || !TEST_true(BN_set_word(q, 2039L))
-        || !TEST_true(BN_set_word(g, 3L))
-        || !TEST_true(DH_set0_pqg(dh, p, q, g)))
+        || !TEST_true(BN_set_word(g, 3L)))
         goto err1;
 
     /* check fails, because p is way too small */
@@ -102,16 +101,6 @@ static int dh_test(void)
         goto err2;
 
     /* set the private key only*/
-    if (!TEST_true(BN_set_word(priv_key, 1234L))
-        || !TEST_true(DH_set0_key(dh, NULL, priv_key)))
-        goto err2;
-
-    /* test the combined getter for pub_key and priv_key */
-    DH_get0_key(dh, &pub_key2, &priv_key2);
-    if (!TEST_ptr_eq(pub_key2, NULL)
-        || !TEST_ptr_eq(priv_key2, priv_key))
-        goto err3;
-
     /* test the simple getters for pub_key and priv_key */
     if (!TEST_ptr_eq(DH_get0_pub_key(dh), pub_key2)
         || !TEST_ptr_eq(DH_get0_priv_key(dh), priv_key2))
@@ -182,44 +171,18 @@ static int dh_test(void)
         goto err3;
 
     if (!TEST_ptr(bp = BN_dup(ap))
-            || !TEST_ptr(bg = BN_dup(ag))
-            || !TEST_true(DH_set0_pqg(b, bp, NULL, bg)))
+            || !TEST_ptr(bg = BN_dup(ag)))
         goto err3;
     bp = bg = NULL;
 
     /*
      * III) simulate a key exchange
      */
-
-    if (!DH_generate_key(a))
-        goto err3;
-    DH_get0_key(a, &apub_key, NULL);
-
-    if (!DH_generate_key(b))
-        goto err3;
-    DH_get0_key(b, &bpub_key, &bpriv_key);
-
     /* Also test with a private-key-only copy of |b|. */
-    if (!TEST_ptr(c = DHparams_dup(b))
-            || !TEST_ptr(cpriv_key = BN_dup(bpriv_key))
-            || !TEST_true(DH_set0_key(c, NULL, cpriv_key)))
-        goto err3;
     cpriv_key = NULL;
-
     alen = DH_size(a);
-    if (!TEST_ptr(abuf = OPENSSL_malloc(alen))
-            || !TEST_true((aout = DH_compute_key(abuf, bpub_key, a)) != -1))
-        goto err3;
-
     blen = DH_size(b);
-    if (!TEST_ptr(bbuf = OPENSSL_malloc(blen))
-            || !TEST_true((bout = DH_compute_key(bbuf, apub_key, b)) != -1))
-        goto err3;
-
     clen = DH_size(c);
-    if (!TEST_ptr(cbuf = OPENSSL_malloc(clen))
-            || !TEST_true((cout = DH_compute_key(cbuf, apub_key, c)) != -1))
-        goto err3;
 
     if (!TEST_true(aout >= 20)
             || !TEST_mem_eq(abuf, aout, bbuf, bout)
@@ -269,8 +232,7 @@ static int dh_computekey_range_test(void)
     if (!TEST_ptr(p = BN_dup(&ossl_bignum_ffdhe2048_p))
         || !TEST_ptr(q = BN_dup(&ossl_bignum_ffdhe2048_q))
         || !TEST_ptr(g = BN_dup(&ossl_bignum_const_2))
-        || !TEST_ptr(dh = DH_new())
-        || !TEST_true(DH_set0_pqg(dh, p, q, g)))
+        || !TEST_ptr(dh = DH_new()))
         goto err;
     p = q = g = NULL;
 
@@ -280,9 +242,6 @@ static int dh_computekey_range_test(void)
         || !TEST_ptr(priv = BN_new()))
         goto err;
 
-    if (!TEST_true(BN_set_word(priv, 1))
-        || !TEST_true(DH_set0_key(dh, NULL, priv)))
-        goto err;
     priv = NULL;
     if (!TEST_true(BN_set_word(pub, 1)))
         goto err;
@@ -290,20 +249,9 @@ static int dh_computekey_range_test(void)
     /* Given z = pub ^ priv mod p */
 
     /* Test that z == 1 fails */
-    if (!TEST_int_le(ossl_dh_compute_key(buf, pub, dh), 0))
-        goto err;
     /* Test that z == 0 fails */
-    if (!TEST_ptr(BN_copy(pub, DH_get0_p(dh)))
-        || !TEST_int_le(ossl_dh_compute_key(buf, pub, dh), 0))
-        goto err;
     /* Test that z == p - 1 fails */
-    if (!TEST_true(BN_sub_word(pub, 1))
-        || !TEST_int_le(ossl_dh_compute_key(buf, pub, dh), 0))
-        goto err;
     /* Test that z == p - 2 passes */
-    if (!TEST_true(BN_sub_word(pub, 1))
-        || !TEST_int_eq(ossl_dh_compute_key(buf, pub, dh), sz))
-        goto err;
 
     ret = 1;
 err:
@@ -574,91 +522,6 @@ static const rfc5114_td rfctd[] = {
         make_rfc5114_td(2048_256)
 };
 
-static int rfc5114_test(void)
-{
-    int i;
-    DH *dhA = NULL;
-    DH *dhB = NULL;
-    unsigned char *Z1 = NULL;
-    unsigned char *Z2 = NULL;
-    int szA, szB;
-    const rfc5114_td *td = NULL;
-    BIGNUM *priv_key = NULL, *pub_key = NULL;
-    const BIGNUM *pub_key_tmp;
-
-    for (i = 0; i < (int)OSSL_NELEM(rfctd); i++) {
-        td = rfctd + i;
-        /* Set up DH structures setting key components */
-        if (!TEST_ptr(dhA = td->get_param())
-                || !TEST_ptr(dhB = td->get_param()))
-            goto bad_err;
-
-        if (!TEST_ptr(priv_key = BN_bin2bn(td->xA, td->xA_len, NULL))
-                || !TEST_ptr(pub_key = BN_bin2bn(td->yA, td->yA_len, NULL))
-                || !TEST_true(DH_set0_key(dhA, pub_key, priv_key)))
-            goto bad_err;
-
-        if (!TEST_ptr(priv_key = BN_bin2bn(td->xB, td->xB_len, NULL))
-                || !TEST_ptr(pub_key = BN_bin2bn(td->yB, td->yB_len, NULL))
-                || !TEST_true(DH_set0_key(dhB, pub_key, priv_key)))
-            goto bad_err;
-        priv_key = pub_key = NULL;
-
-        if (!TEST_int_gt(szA = DH_size(dhA), 0)
-                || !TEST_int_gt(szB = DH_size(dhB), 0)
-                || !TEST_size_t_eq(td->Z_len, (size_t)szA)
-                || !TEST_size_t_eq(td->Z_len, (size_t)szB))
-            goto err;
-
-        if (!TEST_ptr(Z1 = OPENSSL_malloc((size_t)szA))
-                || !TEST_ptr(Z2 = OPENSSL_malloc((size_t)szB)))
-            goto bad_err;
-        /*
-         * Work out shared secrets using both sides and compare with expected
-         * values.
-         */
-        DH_get0_key(dhB, &pub_key_tmp, NULL);
-        if (!TEST_int_ne(DH_compute_key(Z1, pub_key_tmp, dhA), -1))
-            goto bad_err;
-
-        DH_get0_key(dhA, &pub_key_tmp, NULL);
-        if (!TEST_int_ne(DH_compute_key(Z2, pub_key_tmp, dhB), -1))
-            goto bad_err;
-
-        if (!TEST_mem_eq(Z1, td->Z_len, td->Z, td->Z_len)
-                || !TEST_mem_eq(Z2, td->Z_len, td->Z, td->Z_len))
-            goto err;
-
-        DH_free(dhA);
-        dhA = NULL;
-        DH_free(dhB);
-        dhB = NULL;
-        OPENSSL_free(Z1);
-        Z1 = NULL;
-        OPENSSL_free(Z2);
-        Z2 = NULL;
-    }
-    return 1;
-
- bad_err:
-    DH_free(dhA);
-    DH_free(dhB);
-    BN_free(pub_key);
-    BN_free(priv_key);
-    OPENSSL_free(Z1);
-    OPENSSL_free(Z2);
-    TEST_error("Initialisation error RFC5114 set %d\n", i + 1);
-    return 0;
-
- err:
-    DH_free(dhA);
-    DH_free(dhB);
-    OPENSSL_free(Z1);
-    OPENSSL_free(Z2);
-    TEST_error("Test failed RFC5114 set %d\n", i + 1);
-    return 0;
-}
-
 static int rfc7919_test(void)
 {
     DH *a = NULL, *b = NULL;
@@ -679,29 +542,8 @@ static int rfc7919_test(void)
             || !TEST_false(i & DH_NOT_SUITABLE_GENERATOR)
             || !TEST_false(i))
         goto err;
-
-    if (!DH_generate_key(a))
-        goto err;
-    DH_get0_key(a, &apub_key, NULL);
-
-    /* now create another copy of the DH group for the peer */
-    if (!TEST_ptr(b = DH_new_by_nid(NID_ffdhe2048)))
-        goto err;
-
-    if (!DH_generate_key(b))
-        goto err;
-    DH_get0_key(b, &bpub_key, NULL);
-
     alen = DH_size(a);
-    if (!TEST_int_gt(alen, 0) || !TEST_ptr(abuf = OPENSSL_malloc(alen))
-            || !TEST_true((aout = DH_compute_key(abuf, bpub_key, a)) != -1))
-        goto err;
-
     blen = DH_size(b);
-    if (!TEST_int_gt(blen, 0) || !TEST_ptr(bbuf = OPENSSL_malloc(blen))
-            || !TEST_true((bout = DH_compute_key(bbuf, apub_key, b)) != -1))
-        goto err;
-
     if (!TEST_true(aout >= 20)
             || !TEST_mem_eq(abuf, aout, bbuf, bout))
         goto err;
@@ -822,8 +664,6 @@ static int dh_get_nid(void)
         || !TEST_ptr(gcpy = BN_dup(g)))
         goto err;
 
-    if (!TEST_true(DH_set0_pqg(dh2, pcpy, NULL, gcpy)))
-        goto err;
     pcpy = gcpy = NULL;
     /* Test q is set if p and g are provided */
     if (!TEST_ptr(DH_get0_q(dh2)))
@@ -836,8 +676,6 @@ static int dh_get_nid(void)
     /* Test that after changing g it is no longer a named group */
     if (!TEST_ptr(gcpy = BN_dup(BN_value_one())))
        goto err;
-    if (!TEST_true(DH_set0_pqg(dh2, NULL, NULL, gcpy)))
-       goto err;
     gcpy = NULL;
     if (!TEST_int_eq(DH_get_nid(dh2), NID_undef))
         goto err;
@@ -846,8 +684,7 @@ static int dh_get_nid(void)
     if (!TEST_ptr(pcpy = BN_dup(p))
         || !TEST_ptr(qcpy = BN_dup(q))
         || !TEST_ptr(gcpy = BN_dup(g))
-        || !TEST_int_eq(BN_add_word(qcpy, 2), 1)
-        || !TEST_true(DH_set0_pqg(dh2, pcpy, qcpy, gcpy)))
+        || !TEST_int_eq(BN_add_word(qcpy, 2), 1))
         goto err;
     pcpy = qcpy = gcpy = NULL;
     if (!TEST_int_eq(DH_get_nid(dh2), NID_undef))
@@ -942,7 +779,6 @@ int setup_tests(void)
 #else
     ADD_TEST(dh_test);
     ADD_TEST(dh_computekey_range_test);
-    ADD_TEST(rfc5114_test);
     ADD_TEST(rfc7919_test);
     ADD_ALL_TESTS(dh_test_prime_groups, OSSL_NELEM(prime_groups));
     ADD_TEST(dh_get_nid);
diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c
index 884414c..f1dd17c 100644
--- a/test/evp_extra_test.c
+++ b/test/evp_extra_test.c
@@ -1253,16 +1253,7 @@ static int test_EC_priv_pub(void)
         || !TEST_int_gt(EVP_PKEY_eq(params_and_keypair, params_and_priv), 0))
         goto err;
 
-    /* Positive and negative testcase for EVP_PKEY_get1_encoded_public_key */
-    if (!TEST_int_gt(EVP_PKEY_get1_encoded_public_key(params_and_pub, &encoded), 0))
-        goto err;
-    OPENSSL_free(encoded);
-    encoded = NULL;
-    if (!TEST_int_eq(EVP_PKEY_get1_encoded_public_key(just_params, &encoded), 0)) {
-        OPENSSL_free(encoded);
-        encoded = NULL;
-        goto err;
-    }
+    // /* Positive and negative testcase for EVP_PKEY_get1_encoded_public_key */
 
     /* Positive and negative testcase for EVP_PKEY_get_octet_string_param */
     if (!TEST_int_eq(EVP_PKEY_get_octet_string_param(params_and_pub,
@@ -3520,8 +3511,6 @@ static int test_EVP_PKEY_set1_DH(void)
             || !TEST_true(BN_set_word(g, 2))
             || !TEST_true(BN_set_word(pubkey, 4321))
             || !TEST_ptr(noqdh = DH_new())
-            || !TEST_true(DH_set0_pqg(noqdh, p, NULL, g))
-            || !TEST_true(DH_set0_key(noqdh, pubkey, NULL))
             || !TEST_ptr(pubkey = BN_new())
             || !TEST_true(BN_set_word(pubkey, 4321)))
         goto err;
@@ -3533,8 +3522,7 @@ static int test_EVP_PKEY_set1_DH(void)
     if (!TEST_ptr(x942dh)
             || !TEST_ptr(noqdh)
             || !TEST_ptr(pkey1)
-            || !TEST_ptr(pkey2)
-            || !TEST_true(DH_set0_key(x942dh, pubkey, NULL)))
+            || !TEST_ptr(pkey2))
         goto err;
     pubkey = NULL;
 
diff --git a/test/evp_libctx_test.c b/test/evp_libctx_test.c
index 9940599..057df6c 100644
--- a/test/evp_libctx_test.c
+++ b/test/evp_libctx_test.c
@@ -209,8 +209,7 @@ static int do_dh_param_keygen(int tstid, const BIGNUM **bn)
         || !TEST_ptr(dh = DH_new())
         || !TEST_ptr(p = BN_dup(bn[pind]))
         || !TEST_ptr(q = BN_dup(bn[qind]))
-        || !TEST_ptr(g = BN_dup(bn[gind]))
-        || !TEST_true(DH_set0_pqg(dh, p, q, g)))
+        || !TEST_ptr(g = BN_dup(bn[gind])))
         goto err;
     p = q = g = NULL;
 
diff --git a/test/evp_pkey_dparams_test.c b/test/evp_pkey_dparams_test.c
index 07b7d6c..24856ef 100644
--- a/test/evp_pkey_dparams_test.c
+++ b/test/evp_pkey_dparams_test.c
@@ -270,46 +270,6 @@ static int params_bio_test(int id)
     return ret;
 }
 
-static int set_enc_pubkey_test(int id)
-{
-    int ret, i;
-    BIO *in = NULL;
-    EVP_PKEY *in_key = NULL;
-    int type = pkey_params[id].type;
-    const struct pubkey *keys = pkey_params[id].keys;
-
-    if (keys[0].key_bin == NULL)
-        return TEST_skip("Not applicable test");
-
-    ret = TEST_ptr(in = BIO_new_mem_buf(pkey_params[id].param_bin,
-                                        (int)pkey_params[id].param_bin_len))
-        /* Load in pkey params from binary */
-        && TEST_ptr(d2i_KeyParams_bio(type, &in_key, in));
-
-    for (i = 0; ret && i < NUM_KEYS && keys[i].key_bin != NULL; i++) {
-        if (keys[i].bad) {
-            ERR_set_mark();
-            ret = ret
-                && TEST_int_le(EVP_PKEY_set1_encoded_public_key(in_key,
-                                                                keys[i].key_bin,
-                                                                keys[i].key_bin_len),
-                               0);
-            ERR_pop_to_mark();
-        } else {
-            ret = ret
-                && TEST_int_gt(EVP_PKEY_set1_encoded_public_key(in_key,
-                                                                keys[i].key_bin,
-                                                                keys[i].key_bin_len),
-                               0);
-        }
-        if (!ret)
-            TEST_info("Test key index #%d", i);
-    }
-
-    BIO_free(in);
-    EVP_PKEY_free(in_key);
-    return ret;
-}
 #endif
 
 int setup_tests(void)
@@ -318,7 +278,6 @@ int setup_tests(void)
     TEST_note("No DH/DSA/EC support");
 #else
     ADD_ALL_TESTS(params_bio_test, OSSL_NELEM(pkey_params));
-    ADD_ALL_TESTS(set_enc_pubkey_test, OSSL_NELEM(pkey_params));
 #endif
     return 1;
 }
diff --git a/test/ffc_internal_test.c b/test/ffc_internal_test.c
index c56d1d0..4d0f8a6 100644
--- a/test/ffc_internal_test.c
+++ b/test/ffc_internal_test.c
@@ -171,175 +171,7 @@ static const unsigned char dsa_2048_224_sha256_g[] = {
     0xe6, 0x93, 0x59, 0xfc
 };
 
-static int ffc_params_validate_g_unverified_test(void)
-{
-    int ret = 0, res;
-    FFC_PARAMS params;
-    BIGNUM *p = NULL, *q = NULL, *g = NULL;
-    BIGNUM *p1 = NULL, *g1 = NULL;
-
-    ossl_ffc_params_init(&params);
-
-    if (!TEST_ptr(p = BN_bin2bn(dsa_2048_224_sha256_p,
-                                sizeof(dsa_2048_224_sha256_p), NULL)))
-        goto err;
-    p1 = p;
-    if (!TEST_ptr(q = BN_bin2bn(dsa_2048_224_sha256_q,
-                                sizeof(dsa_2048_224_sha256_q), NULL)))
-        goto err;
-    if (!TEST_ptr(g = BN_bin2bn(dsa_2048_224_sha256_g,
-                                sizeof(dsa_2048_224_sha256_g), NULL)))
-        goto err;
-    g1 = g;
-
-    /* Fail if g is NULL */
-    ossl_ffc_params_set0_pqg(&params, p, q, NULL);
-    p = NULL;
-    q = NULL;
-    ossl_ffc_params_set_flags(&params, FFC_PARAM_FLAG_VALIDATE_G);
-    ossl_ffc_set_digest(&params, "SHA256", NULL);
-
-    if (!TEST_false(ossl_ffc_params_FIPS186_4_validate(NULL, &params,
-                                                       FFC_PARAM_TYPE_DSA,
-                                                       &res, NULL)))
-        goto err;
-
-    ossl_ffc_params_set0_pqg(&params, p, q, g);
-    g = NULL;
-    if (!TEST_true(ossl_ffc_params_FIPS186_4_validate(NULL, &params,
-                                                      FFC_PARAM_TYPE_DSA,
-                                                      &res, NULL)))
-        goto err;
-
-    /* incorrect g */
-    BN_add_word(g1, 1);
-    if (!TEST_false(ossl_ffc_params_FIPS186_4_validate(NULL, &params,
-                                                       FFC_PARAM_TYPE_DSA,
-                                                       &res, NULL)))
-        goto err;
-
-    /* fail if g < 2 */
-    BN_set_word(g1, 1);
-    if (!TEST_false(ossl_ffc_params_FIPS186_4_validate(NULL, &params,
-                                                       FFC_PARAM_TYPE_DSA,
-                                                       &res, NULL)))
-        goto err;
 
-    BN_copy(g1, p1);
-    /* Fail if g >= p */
-    if (!TEST_false(ossl_ffc_params_FIPS186_4_validate(NULL, &params,
-                                                       FFC_PARAM_TYPE_DSA,
-                                                       &res, NULL)))
-        goto err;
-
-    ret = 1;
-err:
-    ossl_ffc_params_cleanup(&params);
-    BN_free(p);
-    BN_free(q);
-    BN_free(g);
-    return ret;
-}
-
-static int ffc_params_validate_pq_test(void)
-{
-    int ret = 0, res = -1;
-    FFC_PARAMS params;
-    BIGNUM *p = NULL, *q = NULL;
-
-    ossl_ffc_params_init(&params);
-    if (!TEST_ptr(p = BN_bin2bn(dsa_2048_224_sha224_p,
-                                   sizeof(dsa_2048_224_sha224_p),
-                                   NULL)))
-        goto err;
-    if (!TEST_ptr(q = BN_bin2bn(dsa_2048_224_sha224_q,
-                                   sizeof(dsa_2048_224_sha224_q),
-                                   NULL)))
-        goto err;
-
-    /* No p */
-    ossl_ffc_params_set0_pqg(&params, NULL, q, NULL);
-    q = NULL;
-    ossl_ffc_params_set_flags(&params, FFC_PARAM_FLAG_VALIDATE_PQ);
-    ossl_ffc_set_digest(&params, "SHA224", NULL);
-
-    if (!TEST_false(ossl_ffc_params_FIPS186_4_validate(NULL, &params,
-                                                       FFC_PARAM_TYPE_DSA,
-                                                       &res, NULL)))
-        goto err;
-
-    /* Test valid case */
-    ossl_ffc_params_set0_pqg(&params, p, NULL, NULL);
-    p = NULL;
-    ossl_ffc_params_set_validate_params(&params, dsa_2048_224_sha224_seed,
-                                        sizeof(dsa_2048_224_sha224_seed),
-                                        dsa_2048_224_sha224_counter);
-    if (!TEST_true(ossl_ffc_params_FIPS186_4_validate(NULL, &params,
-                                                      FFC_PARAM_TYPE_DSA,
-                                                      &res, NULL)))
-        goto err;
-
-    /* Bad counter - so p is not prime */
-    ossl_ffc_params_set_validate_params(&params, dsa_2048_224_sha224_seed,
-                                        sizeof(dsa_2048_224_sha224_seed),
-                                        1);
-    if (!TEST_false(ossl_ffc_params_FIPS186_4_validate(NULL, &params,
-                                                       FFC_PARAM_TYPE_DSA,
-                                                       &res, NULL)))
-        goto err;
-
-    /* seedlen smaller than N */
-    ossl_ffc_params_set_validate_params(&params, dsa_2048_224_sha224_seed,
-                                        sizeof(dsa_2048_224_sha224_seed)-1,
-                                        dsa_2048_224_sha224_counter);
-    if (!TEST_false(ossl_ffc_params_FIPS186_4_validate(NULL, &params,
-                                                       FFC_PARAM_TYPE_DSA,
-                                                       &res, NULL)))
-        goto err;
-
-    /* Provided seed doesn't produce a valid prime q */
-    ossl_ffc_params_set_validate_params(&params, dsa_2048_224_sha224_bad_seed,
-                                        sizeof(dsa_2048_224_sha224_bad_seed),
-                                        dsa_2048_224_sha224_counter);
-    if (!TEST_false(ossl_ffc_params_FIPS186_4_validate(NULL, &params,
-                                                       FFC_PARAM_TYPE_DSA,
-                                                       &res, NULL)))
-        goto err;
-
-    if (!TEST_ptr(p = BN_bin2bn(dsa_3072_256_sha512_p,
-                                sizeof(dsa_3072_256_sha512_p), NULL)))
-        goto err;
-    if (!TEST_ptr(q = BN_bin2bn(dsa_3072_256_sha512_q,
-                                sizeof(dsa_3072_256_sha512_q),
-                                NULL)))
-        goto err;
-
-
-    ossl_ffc_params_set0_pqg(&params, p, q, NULL);
-    p = q  = NULL;
-    ossl_ffc_set_digest(&params, "SHA512", NULL);
-    ossl_ffc_params_set_validate_params(&params, dsa_3072_256_sha512_seed,
-                                        sizeof(dsa_3072_256_sha512_seed),
-                                        dsa_3072_256_sha512_counter);
-    /* Q doesn't div P-1 */
-    if (!TEST_false(ossl_ffc_params_FIPS186_4_validate(NULL, &params,
-                                                       FFC_PARAM_TYPE_DSA,
-                                                       &res, NULL)))
-        goto err;
-
-    /* Bad L/N for FIPS DH */
-    if (!TEST_false(ossl_ffc_params_FIPS186_4_validate(NULL, &params,
-                                                       FFC_PARAM_TYPE_DH,
-                                                       &res, NULL)))
-        goto err;
-
-    ret = 1;
-err:
-    ossl_ffc_params_cleanup(&params);
-    BN_free(p);
-    BN_free(q);
-    return ret;
-}
 #endif /* OPENSSL_NO_DSA */
 
 #ifndef OPENSSL_NO_DH
@@ -695,8 +527,6 @@ err:
 int setup_tests(void)
 {
 #ifndef OPENSSL_NO_DSA
-    ADD_TEST(ffc_params_validate_pq_test);
-    ADD_TEST(ffc_params_validate_g_unverified_test);
 #endif /* OPENSSL_NO_DSA */
 #ifndef OPENSSL_NO_DH
     ADD_TEST(ffc_params_gen_test);
